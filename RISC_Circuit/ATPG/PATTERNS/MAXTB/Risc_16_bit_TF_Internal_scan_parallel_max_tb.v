// MAX TB Test Protocol File, generated by MAX TB Version U-2022.12-SP7
// Mon May 20 15:27:38 2024
// Module under test: Risc_16_bit
// Generated from original STIL file : "PATTERNS/STIL/Risc_16_bit_TF_Internal_scan_500.stil.gz"
// STIL file version: "1.0"
// Enhanced Runtime Version (with test data programmability): use <sim_exec> +tmax_help for available runtime options
// Simulation mode: default parallel simulation

`define TDATA_FILE "/home/vlsilab/sagar_harsh_soham/RISC/ATPG/PATTERNS/MAXTB/Risc_16_bit_TF_Internal_scan_parallel_max_tb.dat"
`ifndef XTB_DUT_HIER 
  `define XTB_DUT_HIER dut
`endif
`timescale 1ns/1ns

// OPCODE DEFINITION
`define SetLastReseed 0
`define EndPat 1
`define IncPat 2
`define SetPat 3
`define WFTStmt 4
`define ConditionStmt 5
`define VectorStmt 6
`define FixedStmt 7
`define GenLoopStmt 8
`define EndGenLoopStmt 9
`define GenTestSetupStmt 10
`define EndGenTestSetupStmt 11
`define SetForceSI 12
`define SetValidStrobe 13
`define AnnotationStmt 14
`define SetWPack 15
`define SetRPack 16
`define multiclock_captureStmt 17
`define allclock_captureStmt 18
`define allclock_launchStmt 19
`define allclock_launch_captureStmt 20
`define load_unloadStmt 21
`define test_setupStmt 22

// SIGS DEFINITION
`define clk 0
`define TEST_SI1 1
`define TEST_SI2 2
`define TEST_SI3 3
`define TEST_SI4 4
`define TEST_SE 5
`define scan_clk 6
`define SCAN_MODE 7
`define pll_bypass_2 8
`define pll_bypass 9
`define pll_reset 10
`define TEST_SO1 11
`define TEST_SO2 12
`define TEST_SO3 13
`define TEST_SO4 14
`define _pi 15
`define all_inputs 16
`define _po 17
`define _si 18
`define all_outputs 19
`define _clk 20
`define _so 21

// WFTS DEFINITION
`define _multiclock_capture_WFT_ 0
`define _allclock_capture_WFT_ 1
`define _allclock_launch_WFT_ 2
`define _allclock_launch_capture_WFT_ 3
`define _default_WFT_ 4
`define MAX_PART 0

`define MAXTB_HEADER " MAX TB Version U-2022.12-SP7\n Test Protocol File generated from original file \"PATTERNS/STIL/Risc_16_bit_TF_Internal_scan_500.stil.gz\"\n STIL file version: 1.0"
`define MAXTB_H_S "#############################################################################"


module /* maxtb */ Risc_16_bit_test ();
   parameter NSTMTS = 23; // number of all stmts
   parameter DFSHIFTS = 0; // (default) number of serial shifts in parallel scan mode
   parameter NAMELENGTH = 200; // max length of names reported in fails
   parameter SC_NAMELENGTH = 43; // max length of scan cell names reported in fails
   parameter FILELENGTH = 1024; // max length for file names 
   parameter MAXCHLEN = 91, NCHAINS = 4;
   parameter NINPUTS = 11, NOUTPUTS = 4, CUM_WIDTH=55;
   parameter NSIS = 4, NSOUTS = 4;
   parameter WFT_IDS = 5, SIG_IDS = 22, SIG_IDS_W = 5, MAX_WIDTH = 11, MAX_SIGW = 1;
   parameter PARSERINC = 91; 
   parameter SYNC_LATENCY = 3; 
   parameter PRTIME = 0.000000; 
   parameter PSTIME = 0.000000; 
   parameter MDEPTH = 537; 
   integer xtb_sim_mode; // simulation modes: xtb_sim_mode=0 -> serial, xtb_sim_mode=1 -> parallel (default);

   integer f_part, l_part;
   integer nbfails, abit, cbit;
   integer prev_error; // flag for tracking displayed error banner
   integer loads;        // number of load_unloads for current pattern
   integer prev_pat;     // previous pattern number;
   integer rep_pat; // report pattern progress every Nth pattern
   integer verbose;      // message verbosity level
   integer debug;      // enable debug level
   integer test_setup_runs; // counts the number of executed test_setups
   integer test_setup_only_once; // flag to trigger only one execution of test_setup
   integer data_i, n, cur_pat, start_pat, end_pat, last_pat, total_pats, csci, fsci, cur_stmt, n_pat_sim;
   integer v_count, v_count_per_pat;  // track the cycle count and cycle/pattern count (helpful for the simulator GUI)
   integer v_count_per_stmt;  // track the cycle count per statement (procedure or macro)
   integer SSHIFTS;
   integer diagf, diagm;
   integer sertmg;
   integer test_setup_mode; 
   reg test_setup_done; 
   integer the_wft_id, wft_id_s;
   integer ser_pats;
   integer first_pat;
   event start_part, end_part;
   event error_ev;
   `define SIGCODE 95023
   `define NBRTOPS 12
   integer csim_op;
   reg [32*8:1] RT_OPS [0:`NBRTOPS];
   integer      rt_ops [0:`NBRTOPS-1];
   integer      tdfm;
   integer lp_addr, lp_count, lp_max;
   reg [0:(8*FILELENGTH)-1] TDATA_FILE;

   reg [MAX_SIGW*(NINPUTS+NOUTPUTS)-1:0] ALLINSIGS, ALLOUTSIGS;
   reg [MAX_SIGW*(NINPUTS+NOUTPUTS)-1:0] TMPINSIGS_V,TMPINSIGS_T,TMPINSIGS_V_S,TMPINSIGS_T_S;
   reg [MAX_SIGW*(NINPUTS+NOUTPUTS)-1:0] TMPOUTSIGS_V,TMPOUTSIGS_T,TMPOUTSIGS_V_S,TMPOUTSIGS_T_S;
   reg [NINPUTS+NOUTPUTS-1:0] ALLINSIGIDS, ALLOUTSIGIDS, ALLINSIGIDS_S, ALLOUTSIGIDS_S;
   reg [NSTMTS-1:0] opcode, popcode;
   event force_scells;
   event strobe_scells;
   event release_scells;
   reg [114:0] memel, memall [1:MDEPTH];
   reg [0:(8*NAMELENGTH)-1] CH_NAMES [0:NCHAINS-1];
   reg [0:(8*NAMELENGTH)-1] CH_PINS [0:NCHAINS-1];
   reg [0:8*(SC_NAMELENGTH-1)] SC_NAMES[0:(NCHAINS*MAXCHLEN)-1];
   reg [0:MAXCHLEN-1] LOD, LOAD[0:NCHAINS-1];
   reg [0:MAXCHLEN-1] UNL, UNLOAD[0:NCHAINS-1];
   reg [0:MAXCHLEN-1] UNLM;
   reg [0:MAXCHLEN-1] SERIALM;
   reg [0:MAXCHLEN-1] CH_INPINV[0:NCHAINS-1], CH_OUTINV[0:NCHAINS-1];
   reg [0:MAXCHLEN-1] CT_OUTINV[0:NCHAINS-1];
   wire [0:NCHAINS-1] SCANOUT;
   reg [0:MAXCHLEN-1] CHOUT, CHAINOUT[0:NCHAINS-1];
   reg [0:MAXCHLEN-1] CHAINOUT0,  CHAINOUT1,  CHAINOUT2,  CHAINOUT3;
   reg [0:MAXCHLEN-1] LOD0,  LOD1,  LOD2,  LOD3;
   integer set_last_reseed;
   reg strobe_en;
   reg [SIG_IDS-1:0] sid_args ;
   reg [2*CUM_WIDTH-1:0] sval_args;
   reg [4:0] the_sids [0:SIG_IDS-1];
   reg [8*NAMELENGTH-1:0]  SignalIDName [0:21];
   reg [2:0]  SignalIDType [0:21];
   reg [3:0]  SignalIDWidth [0:21];
   reg [(8*NAMELENGTH-1):0]  WFTIDName [0:4];
   reg [0:(8*FILELENGTH)-1] diag_file;
   reg [0:(8*NAMELENGTH-1)] StmtNames [0:NSTMTS];

   reg clk_con ;
   reg TEST_SI1_con ;
   reg TEST_SI2_con ;
   reg TEST_SI3_con ;
   reg TEST_SI4_con ;
   reg TEST_SE_con ;
   reg scan_clk_con ;
   reg SCAN_MODE_con ;
   reg pll_bypass_2_con ;
   reg pll_bypass_con ;
   reg pll_reset_con ;
   wire TEST_SO1_con ;
   wire TEST_SO2_con ;
   wire TEST_SO3_con ;
   wire TEST_SO4_con ;

   wire [0:(8*NAMELENGTH-1)] cur_StmtName;
   assign cur_StmtName = StmtNames[cur_stmt] ;


   Risc_16_bit dut ( 
     .clk ( clk_con ),
     .TEST_SI1 ( TEST_SI1_con ),
     .TEST_SI2 ( TEST_SI2_con ),
     .TEST_SI3 ( TEST_SI3_con ),
     .TEST_SI4 ( TEST_SI4_con ),
     .TEST_SE ( TEST_SE_con ),
     .scan_clk ( scan_clk_con ),
     .SCAN_MODE ( SCAN_MODE_con ),
     .pll_bypass_2 ( pll_bypass_2_con ),
     .pll_bypass ( pll_bypass_con ),
     .pll_reset ( pll_reset_con ),
     .TEST_SO1 ( TEST_SO1_con ),
     .TEST_SO2 ( TEST_SO2_con ),
     .TEST_SO3 ( TEST_SO3_con ),
     .TEST_SO4 ( TEST_SO4_con )
  );


   task save_context;
     begin
       wft_id_s = the_wft_id;
       TMPINSIGS_V_S = TMPINSIGS_V;
       TMPOUTSIGS_V_S = TMPOUTSIGS_V;
       TMPINSIGS_T_S = TMPINSIGS_T;
       TMPOUTSIGS_T_S = TMPOUTSIGS_T;
       ALLOUTSIGIDS_S = ALLOUTSIGIDS;
       ALLINSIGIDS_S = ALLINSIGIDS;
     end
   endtask 

   task restore_context;
     begin
       the_wft_id = wft_id_s;
       TMPINSIGS_V = TMPINSIGS_V_S;
       TMPOUTSIGS_V = TMPOUTSIGS_V_S;
       TMPINSIGS_T = TMPINSIGS_T_S;
       TMPOUTSIGS_T = TMPOUTSIGS_T_S;
       ALLOUTSIGIDS = ALLOUTSIGIDS_S;
       ALLINSIGIDS = ALLINSIGIDS_S;
     end
   endtask 

   task resolve_signal;
     input reg [4:0] sid;
   begin
     if (SignalIDType[sid] != 3) the_sids[0] = sid;
     else begin
       case (sid)
         'd15: begin // _pi
                 the_sids[10] = 7; the_sids[9] = 5; the_sids[8] = 1; the_sids[7] = 2; the_sids[6] = 3; the_sids[5] = 4; the_sids[4] = 0; the_sids[3] = 8; the_sids[2] = 6; the_sids[1] = 9;
                 the_sids[0] = 10;
               end
         'd16: begin // all_inputs
                 the_sids[10] = 7; the_sids[9] = 5; the_sids[8] = 1; the_sids[7] = 2; the_sids[6] = 3; the_sids[5] = 4; the_sids[4] = 0; the_sids[3] = 8; the_sids[2] = 6; the_sids[1] = 9;
                 the_sids[0] = 10;
               end
         'd17: begin // _po
                 the_sids[3] = 11; the_sids[2] = 12; the_sids[1] = 13;
                 the_sids[0] = 14;
               end
         'd18: begin // _si
                 the_sids[3] = 1; the_sids[2] = 2; the_sids[1] = 3;
                 the_sids[0] = 4;
               end
         'd19: begin // all_outputs
                 the_sids[3] = 11; the_sids[2] = 12; the_sids[1] = 13;
                 the_sids[0] = 14;
               end
         'd20: begin // _clk
                 the_sids[1] = 0;
                 the_sids[0] = 6;
               end
         'd21: begin // _so
                 the_sids[3] = 11; the_sids[2] = 12; the_sids[1] = 13;
                 the_sids[0] = 14;
               end
          default: begin $display("\nXTB Error: unrecognized signal id %d (valid range is 0..%d). Exiting...",sid, SIG_IDS); $finish; end
       endcase
     end
   end
   endtask

   task get_stb_sig;
     input reg [4:0] sid ;
     output reg [MAX_WIDTH-1:0] strsig;
   begin
     case (sid)
       'd11:	strsig[0:0] = 	TEST_SO1_con ;
       'd12:	strsig[0:0] = 	TEST_SO2_con ;
       'd13:	strsig[0:0] = 	TEST_SO3_con ;
       'd14:	strsig[0:0] = 	TEST_SO4_con ;
       default: begin $display("\nXTB Error: unrecognized output signal id %d. Exiting...",sid); $finish; end
     endcase
   end
   endtask

   task set_force_sig;
     input reg [SIG_IDS-1:0] sid ;
   begin
     case (sid)
       'd0: clk_con 	= ALLINSIGS[sid];
       'd1: TEST_SI1_con 	= ALLINSIGS[sid];
       'd2: TEST_SI2_con 	= ALLINSIGS[sid];
       'd3: TEST_SI3_con 	= ALLINSIGS[sid];
       'd4: TEST_SI4_con 	= ALLINSIGS[sid];
       'd5: TEST_SE_con 	= ALLINSIGS[sid];
       'd6: scan_clk_con 	= ALLINSIGS[sid];
       'd7: SCAN_MODE_con 	= ALLINSIGS[sid];
       'd8: pll_bypass_2_con 	= ALLINSIGS[sid];
       'd9: pll_bypass_con 	= ALLINSIGS[sid];
       'd10: pll_reset_con 	= ALLINSIGS[sid];
       default: begin $display("\nXTB Error: unrecognized (input) signal id %d (valid range is 0..%d). Exiting...",sid, SIG_IDS-1); $finish; end
     endcase
   end
   endtask 

   always  begin: force_sigs_p
     reg [SIG_IDS-1:0] sid; 
     reg [MAX_SIGW-1:0] sig;
     fork
        forever @(ALLINSIGS[0]) set_force_sig('d`clk );
        forever @(ALLINSIGS[1]) set_force_sig('d`TEST_SI1 );
        forever @(ALLINSIGS[2]) set_force_sig('d`TEST_SI2 );
        forever @(ALLINSIGS[3]) set_force_sig('d`TEST_SI3 );
        forever @(ALLINSIGS[4]) set_force_sig('d`TEST_SI4 );
        forever @(ALLINSIGS[5]) set_force_sig('d`TEST_SE );
        forever @(ALLINSIGS[6]) set_force_sig('d`scan_clk );
        forever @(ALLINSIGS[7]) set_force_sig('d`SCAN_MODE );
        forever @(ALLINSIGS[8]) set_force_sig('d`pll_bypass_2 );
        forever @(ALLINSIGS[9]) set_force_sig('d`pll_bypass );
        forever @(ALLINSIGS[10]) set_force_sig('d`pll_reset );
     join
   end

   task measure_out_sig;
     input reg [SIG_IDS-1:0] sid ;
     input integer  stmtid;
     reg [MAX_WIDTH-1:0] xsig;
     reg [MAX_WIDTH-1:0] csig;
     integer errshown, abit, cpat;
   begin
     errshown = 0;
     cpat = cur_pat < 0 ? 0 : cur_pat;
     get_stb_sig(sid,csig);
     xsig = ALLOUTSIGS[sid ];
     for (abit = 0; abit < SignalIDWidth[sid]; abit = abit + 1) begin
       if (xsig[abit] !== 1'bx) begin
         if (xsig[abit] !== csig[abit]) begin
           if (errshown == 0) $display(">>>  Error during %0s pattern %0d", StmtNames[stmtid], cpat);
           if (SignalIDWidth[sid] <= 1) begin 
             $display(">>>  \tAt T=%0t, V=%0d, exp=%b, got=%b, signal %0s", $time, v_count, xsig[abit], csig[abit], SignalIDName[sid]);
             if (diagf) begin 
               if (diagm==2) $fdisplay(diagf, "  C %0s %0d (exp=%b, got=%b)", SignalIDName[sid], v_count, xsig[abit], csig[abit]);
               else $fdisplay(diagf, "  %0d %0s (exp=%b, got=%b)", cpat, SignalIDName[sid], xsig[abit], csig[abit]);
             end 
           end 
           else begin 
             $display(">>>  \tAt T=%0t, V=%0d, exp=%b, got=%b, signal %0s[%0d]", $time, v_count, xsig[abit], csig[abit], SignalIDName[sid], abit);
             if (diagf) begin 
               if (diagm==2) $fdisplay(diagf, "  C %0s[%0d] %0d (exp=%b, got=%b)", SignalIDName[sid], abit, v_count, xsig[abit], csig[abit]);
               else $fdisplay(diagf, "  %0d %0s[%d] (exp=%b, got=%b)", cpat, SignalIDName[sid], abit, xsig[abit], csig[abit]);
             end 
           end 
           nbfails = nbfails + 1;
           errshown = 1;
           ->error_ev;
         end 
       end 
     end 
   end 
   endtask

   task measure_scan_out;
     input reg [SIG_IDS-1:0] sid ;
     input integer  chain;
     reg [MAX_WIDTH-1:0] xsig;
     reg [MAX_WIDTH-1:0] csig;
     integer errshown, patoff;
   begin
     if (rt_ops[7] != -1 && cur_pat <= (first_pat) && loads<=1 ) disable measure_scan_out;
     errshown = 0;
     get_stb_sig(sid, csig);
     xsig = ALLOUTSIGS[sid ];
     if ((xsig[0] !==1'bx) && (xsig[0] !== csig[0])) begin
       patoff = (loads > 1 || cur_pat <= 0) ? 0 : 1;
       if (prev_error != cur_pat) begin
         if (cur_pat <= 0 || cur_pat == last_pat && loads > 1) begin
           $display(">>>  Error during scan pattern %0d %s", (cur_pat < 0) ? 0 : cur_pat,  (cur_pat == last_pat) ? "(detected from final pattern unload)" : "");
         end
         else begin
           if (loads > 1) $display(">>>  Error during scan pattern %0d (detected from %0d load/unload)", cur_pat, loads);
           else begin $display(">>>  Error during scan pattern %0d (detected from unload of pattern %0d)", cur_pat, cur_pat-1); end
         end 
         prev_error = cur_pat;
       end
       $display(">>>  \tAt T=%0t, V=%0d, exp=%b, got=%b, chain %0s, pin %0s, scan cell %0d, cell name %0s", $time, v_count, xsig[0], csig[0], CH_NAMES[chain], SignalIDName[sid], fsci, SC_NAMES[(chain*MAXCHLEN)+fsci]);
       if (diagf) begin 
         if (diagm==2) $fdisplay(diagf, "  C %0s %0d (exp=%b, got=%b)", SignalIDName[sid], v_count, xsig[0], csig[0]);
          else $fdisplay(diagf, "  %0d %0s %0d (exp=%b, got=%b)", cur_pat-patoff, SignalIDName[sid], fsci, xsig[0], csig[0]);
       end 
       nbfails = nbfails + 1;
       ->error_ev;
             check_max_error_limit;
     end
   end 
   endtask

   always begin: measure_sigs_p
    fork
     forever @(ALLOUTSIGS['d`TEST_SO1]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_captureStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_launch_captureStmt || cur_stmt == `load_unloadStmt )
       if (cur_stmt ==`load_unloadStmt) measure_scan_out('d`TEST_SO1, 0); 
       else measure_out_sig('d`TEST_SO1, cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`TEST_SO2]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_captureStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_launch_captureStmt || cur_stmt == `load_unloadStmt )
       if (cur_stmt ==`load_unloadStmt) measure_scan_out('d`TEST_SO2, 1); 
       else measure_out_sig('d`TEST_SO2, cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`TEST_SO3]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_captureStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_launch_captureStmt || cur_stmt == `load_unloadStmt )
       if (cur_stmt ==`load_unloadStmt) measure_scan_out('d`TEST_SO3, 2); 
       else measure_out_sig('d`TEST_SO3, cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`TEST_SO4]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt || cur_stmt == `allclock_captureStmt || cur_stmt == `allclock_launchStmt || cur_stmt == `allclock_launch_captureStmt || cur_stmt == `load_unloadStmt )
       if (cur_stmt ==`load_unloadStmt) measure_scan_out('d`TEST_SO4, 3); 
       else measure_out_sig('d`TEST_SO4, cur_stmt); 
     end
    join
   end 

   task undef_wfc;
     input reg [1:0] wfc;
     input reg [4:0] sid;
     input integer wftid;
   begin
     $display("XTB Error: unrecognized %s value (WFC):%0b, on signal %0s for WFT %0s. Exiting...", wfc[1]?"strobe":"force", wfc[0], SignalIDName[sid], WFTIDName[wftid]);
     $finish;
   end
   endtask

   task apply__multiclock_capture_WFT_WFT;
     reg [SIG_IDS_W-1:0] sid;
     reg [SIG_IDS_W-1:0] n;
     reg [SIG_IDS-1:0] s;
   begin
     for (sid=0; sid < SIG_IDS; sid=sid+1) begin
       n=0; 
       case(sid)
         'd7, 'd5, 'd1, 'd2, 'd3, 'd4, 'd8, 'd9, 'd10: // SCAN_MODE, TEST_SE, TEST_SI1, TEST_SI2, TEST_SI3, TEST_SI4, pll_bypass_2, pll_bypass, pll_reset_con
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 0);
               endcase
             end
           end
         end 
         'd11, 'd12, 'd13, 'd14: // TEST_SO1, TEST_SO2, TEST_SO3, TEST_SO4_con
         begin
           if (ALLOUTSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPOUTSIGS_T[MAX_SIGW*sid+n],TMPOUTSIGS_V[MAX_SIGW*sid+n]})
                 2'b1X: begin 
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'bX;   end
                 2'b11: begin 
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'b1;   end
                 2'b10: begin 
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'b0;   end
                 2'b1Z: begin 
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'bZ;   end
                 default: undef_wfc({TMPOUTSIGS_T[MAX_SIGW*sid+n],TMPOUTSIGS_V[MAX_SIGW*sid+n]}, sid, 0);
               endcase
             end
           end
         end 
         'd0: // clk
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 2'bZ1: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(45) 1'b1;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(95) 1'b0;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 0);
               endcase
             end
           end
         end 
         'd6: // scan_clk
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 2'bZ1: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(45) 1'b1;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(95) 1'b0;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 0);
               endcase
             end
           end
         end 
       endcase 
     end 
   end 
   endtask

   task apply__allclock_capture_WFT_WFT;
     reg [SIG_IDS_W-1:0] sid;
     reg [SIG_IDS_W-1:0] n;
     reg [SIG_IDS-1:0] s;
   begin
     for (sid=0; sid < SIG_IDS; sid=sid+1) begin
       n=0; 
       case(sid)
         'd7, 'd5, 'd1, 'd2, 'd3, 'd4, 'd8, 'd9, 'd10: // SCAN_MODE, TEST_SE, TEST_SI1, TEST_SI2, TEST_SI3, TEST_SI4, pll_bypass_2, pll_bypass, pll_reset_con
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 1);
               endcase
             end
           end
         end 
         'd11, 'd12, 'd13, 'd14: // TEST_SO1, TEST_SO2, TEST_SO3, TEST_SO4_con
         begin
           if (ALLOUTSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPOUTSIGS_T[MAX_SIGW*sid+n],TMPOUTSIGS_V[MAX_SIGW*sid+n]})
                 2'b1X: begin 
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'bX;   end
                 2'b11: begin 
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'b1;   end
                 2'b10: begin 
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'b0;   end
                 2'b1Z: begin 
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'bZ;   end
                 default: undef_wfc({TMPOUTSIGS_T[MAX_SIGW*sid+n],TMPOUTSIGS_V[MAX_SIGW*sid+n]}, sid, 1);
               endcase
             end
           end
         end 
         'd0: // clk
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 2'bZ1: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(45) 1'b1;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(95) 1'b0;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 1);
               endcase
             end
           end
         end 
         'd6: // scan_clk
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 2'bZ1: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(45) 1'b1;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(95) 1'b0;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 1);
               endcase
             end
           end
         end 
       endcase 
     end 
   end 
   endtask

   task apply__allclock_launch_WFT_WFT;
     reg [SIG_IDS_W-1:0] sid;
     reg [SIG_IDS_W-1:0] n;
     reg [SIG_IDS-1:0] s;
   begin
     for (sid=0; sid < SIG_IDS; sid=sid+1) begin
       n=0; 
       case(sid)
         'd7, 'd5, 'd1, 'd2, 'd3, 'd4, 'd8, 'd9, 'd10: // SCAN_MODE, TEST_SE, TEST_SI1, TEST_SI2, TEST_SI3, TEST_SI4, pll_bypass_2, pll_bypass, pll_reset_con
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 2);
               endcase
             end
           end
         end 
         'd11, 'd12, 'd13, 'd14: // TEST_SO1, TEST_SO2, TEST_SO3, TEST_SO4_con
         begin
           if (ALLOUTSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPOUTSIGS_T[MAX_SIGW*sid+n],TMPOUTSIGS_V[MAX_SIGW*sid+n]})
                 2'b1X: begin 
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'bX;   end
                 2'b11: begin 
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'b1;   end
                 2'b10: begin 
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'b0;   end
                 2'b1Z: begin 
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'bZ;   end
                 default: undef_wfc({TMPOUTSIGS_T[MAX_SIGW*sid+n],TMPOUTSIGS_V[MAX_SIGW*sid+n]}, sid, 2);
               endcase
             end
           end
         end 
         'd0: // clk
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 2'bZ1: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(45) 1'b1;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(95) 1'b0;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 2);
               endcase
             end
           end
         end 
         'd6: // scan_clk
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 2'bZ1: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(45) 1'b1;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(95) 1'b0;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 2);
               endcase
             end
           end
         end 
       endcase 
     end 
   end 
   endtask

   task apply__allclock_launch_capture_WFT_WFT;
     reg [SIG_IDS_W-1:0] sid;
     reg [SIG_IDS_W-1:0] n;
     reg [SIG_IDS-1:0] s;
   begin
     for (sid=0; sid < SIG_IDS; sid=sid+1) begin
       n=0; 
       case(sid)
         'd7, 'd5, 'd1, 'd2, 'd3, 'd4, 'd8, 'd9, 'd10: // SCAN_MODE, TEST_SE, TEST_SI1, TEST_SI2, TEST_SI3, TEST_SI4, pll_bypass_2, pll_bypass, pll_reset_con
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 3);
               endcase
             end
           end
         end 
         'd11, 'd12, 'd13, 'd14: // TEST_SO1, TEST_SO2, TEST_SO3, TEST_SO4_con
         begin
           if (ALLOUTSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPOUTSIGS_T[MAX_SIGW*sid+n],TMPOUTSIGS_V[MAX_SIGW*sid+n]})
                 2'b1X: begin 
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'bX;   end
                 2'b11: begin 
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'b1;   end
                 2'b10: begin 
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'b0;   end
                 2'b1Z: begin 
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'bZ;   end
                 default: undef_wfc({TMPOUTSIGS_T[MAX_SIGW*sid+n],TMPOUTSIGS_V[MAX_SIGW*sid+n]}, sid, 3);
               endcase
             end
           end
         end 
         'd0: // clk
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 2'bZ1: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(45) 1'b1;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(95) 1'b0;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 3);
               endcase
             end
           end
         end 
         'd6: // scan_clk
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 2'bZ1: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(45) 1'b1;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(95) 1'b0;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 3);
               endcase
             end
           end
         end 
       endcase 
     end 
   end 
   endtask

   task apply__default_WFT_WFT;
     reg [SIG_IDS_W-1:0] sid;
     reg [SIG_IDS_W-1:0] n;
     reg [SIG_IDS-1:0] s;
   begin
     for (sid=0; sid < SIG_IDS; sid=sid+1) begin
       n=0; 
       case(sid)
         'd7, 'd5, 'd1, 'd2, 'd3, 'd4, 'd8, 'd9, 'd10: // SCAN_MODE, TEST_SE, TEST_SI1, TEST_SI2, TEST_SI3, TEST_SI4, pll_bypass_2, pll_bypass, pll_reset_con
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 4);
               endcase
             end
           end
         end 
         'd11, 'd12, 'd13, 'd14: // TEST_SO1, TEST_SO2, TEST_SO3, TEST_SO4_con
         begin
           if (ALLOUTSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPOUTSIGS_T[MAX_SIGW*sid+n],TMPOUTSIGS_V[MAX_SIGW*sid+n]})
                 2'b1X: begin 
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'bX;   end
                 2'b11: begin 
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'b1;   end
                 2'b10: begin 
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'b0;   end
                 2'b1Z: begin 
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(40) 1'bZ;   end
                 default: undef_wfc({TMPOUTSIGS_T[MAX_SIGW*sid+n],TMPOUTSIGS_V[MAX_SIGW*sid+n]}, sid, 4);
               endcase
             end
           end
         end 
         'd6: // scan_clk
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 2'bZ1: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(45) 1'b1;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(95) 1'b0;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 4);
               endcase
             end
           end
         end 
         'd0: // clk
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 2'bZ1: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(45) 1'b1;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(95) 1'b0;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 4);
               endcase
             end
           end
         end 
       endcase 
     end 
   end 
   endtask

   task resolve_wft;
     input integer wftid ;
   begin
     if (wftid > WFT_IDS || wftid <0) begin 
       $display("\nXTB Error: undefined WFT id %0d (valid range is 0..%0d). Exiting...",wftid, WFT_IDS);
       $finish;
     end
     the_wft_id = wftid;
   end
   endtask

   task apply_wft; 
     input integer wftid ;
   begin
     case (wftid) 
       'd0: apply__multiclock_capture_WFT_WFT;
       'd1: apply__allclock_capture_WFT_WFT;
       'd2: apply__allclock_launch_WFT_WFT;
       'd3: apply__allclock_launch_capture_WFT_WFT;
       'd4: apply__default_WFT_WFT;
       default:begin $display("\nXTB Error: undefined WFT id %d. Exiting...",wftid); $finish; end
     endcase
   end
   endtask 

   task complete_cycle;
     input integer wft_id ;
   begin
     case(wft_id)
       'd0: #(100); // _multiclock_capture_WFT_
       'd1: #(100); // _allclock_capture_WFT_
       'd2: #(100); // _allclock_launch_WFT_
       'd3: #(100); // _allclock_launch_capture_WFT_
       'd4: #(100); // _default_WFT_
     endcase
   end
   endtask

   task set_args;
     input reg [4:0] nargs;
     integer i, na;
     reg [2*CUM_WIDTH-1:0] sidx;
     reg [SIG_IDS_W-1:0] sid; 
   begin
     na = 0; sid_args = 'b0; sval_args = 'b0;
     while (na < nargs) begin
       data_i = data_i + 1;
       memel = memall[data_i];
       sid = memel[SIG_IDS_W-1:0];
       if (sid > SIG_IDS-1) begin
         $display($time, "\nXTB Error: Passing wrong signal ID (%0b), valid range is 1..%0d. Exiting...", sid, SIG_IDS-1);
         $finish; 
       end
       sid_args[sid] = 1'b1;
       sidx = sig_idx(sid);
       for (i = 0; i < 2*SignalIDWidth[sid]; i = i + 1)
         sval_args[sidx+i] = memel[i+SIG_IDS_W];
       na=na+1; 
    end  
  end 
  endtask

   function [2*CUM_WIDTH-1:0] sig_idx;
     input reg [SIG_IDS_W-1:0] sid;
     integer i; 
   begin
     sig_idx = 0;
     for (i = 0; i < sid; i = i + 1)  sig_idx = sig_idx+2*SignalIDWidth[i]; 
   end 
   endfunction

   task  assign_mval;
     input reg [SIG_IDS_W-1:0] sid;
     input reg [2*MAX_WIDTH-1:0] msval;
     reg [2*CUM_WIDTH-1:0] sidx;
     reg [2*MAX_WIDTH-1:0] sval;
     integer i;
   begin 
     sidx = sig_idx(sid);
     for (i = 0; i<2*SignalIDWidth[sid]; i = i + 1) sval[i] = (msval[SignalIDWidth[sid] + i] !== 1'bx && i < SignalIDWidth[sid]) ? msval[i] : sval_args[sidx+i]  ;
     assign_val(sid , sval);
   end 
   endtask

   task  assign_ival;
     input reg [SIG_IDS_W-1:0] sid;
     reg [2*CUM_WIDTH-1:0] sidx;
     reg [2*MAX_WIDTH-1:0] sval;
     integer i;
   begin 
     sidx = sig_idx(sid);
     for (i = 0; i<2*SignalIDWidth[sid]; i = i + 1) sval[i] = sval_args[sidx+i];
     assign_val(sid , sval);
   end 
   endtask

   task  assign_val;
     input reg [SIG_IDS_W-1:0] sid;
     input reg [2*MAX_WIDTH-1:0] sval;
     reg [MAX_WIDTH-1:0] nb; 
     reg [6:0] idx;
     integer n, ns;
   begin
     if (sid > SIG_IDS-1 || sid < 0) begin
       $display("\nXTB Error: Passing wrong signal ID (%d), valid range is 1..%0d. Exiting...", sid, SIG_IDS-1);
       $finish;
     end
     resolve_signal(sid);
     idx = 0; 
     ns = (SignalIDType[sid]==3) ? SignalIDWidth[sid] : 1;
     for (n = 0; n < ns; n = n + 1)
     begin
       if (sval[idx+SignalIDWidth[sid]] === 1'b1) begin
         for (nb = 0; nb < SignalIDWidth[the_sids[n]]; nb = nb + 1) begin
           TMPOUTSIGS_V[MAX_SIGW*the_sids[n]+nb]  = sval[idx+nb];
           TMPOUTSIGS_T[MAX_SIGW*the_sids[n]+nb]  = sval[idx+nb+SignalIDWidth[sid]];
           ALLOUTSIGIDS[the_sids[n]] = 1'b1; 
           if (sval[idx+nb] !== 1'bx)
             ALLINSIGIDS[the_sids[n]] = 1'b0;
         end
       end
       else begin
         for (nb = 0; nb < SignalIDWidth[the_sids[n]]; nb = nb + 1) begin
           TMPINSIGS_V[MAX_SIGW*the_sids[n]+nb]  = sval[idx+nb];
           TMPINSIGS_T[MAX_SIGW*the_sids[n]+nb]  = sval[idx+nb+SignalIDWidth[sid]];
           ALLINSIGIDS[the_sids[n]] = 1'b1;
           ALLOUTSIGIDS[the_sids[n]] = 1'b0;
       end 
     end
     idx = idx+SignalIDWidth[the_sids[n]];
     end 
   end 
   endtask

   task  check_sid_args;
     input reg [(NAMELENGTH-1):0] tname;
     input reg [SIG_IDS-1:0] vargs ;
     input reg [SIG_IDS-1:0] cargs ;
     integer i;
   begin
     for (i = 0; i < SIG_IDS-1; i = i + 1)
       if (cargs[i] === 1'b1 && vargs[i] !== 1'b1) begin
         $display("\nXTB Error: Passing wrong signal argument (%s), to Macro/Procedure %s. Exiting...", SignalIDName[i], tname); 
         $finish;
       end 
   end 
   endtask

   task  assign_stmt;
     input integer wftid ;
   begin
     v_count = v_count+1;
     v_count_per_pat = v_count_per_pat+1;
     v_count_per_stmt = v_count_per_stmt+1;
     if (verbose >= 4) $display("XTB: Starting V# %0d at time %0t", v_count, $time);
     apply_wft(wftid);
     complete_cycle(wftid);
   end
   endtask

   task display_stmt;
     input integer stmtid;
   begin
     $display("XTB: Processed statement: %0s", StmtNames[stmtid]);
   end
   endtask

   task read_data;
      integer tdf;
     begin
      tdf = $fopen(TDATA_FILE, "r");
      if (!tdf) begin 
         $display("XTB Error: cannot open %0s file. Exiting...\n", TDATA_FILE);
         $finish; 
      end 
      $fclose(tdf); 
     if (tdfm > 0) $display("XTB: Setting test data file to \"%0s\" (at %0s). Running simulation with new database...", TDATA_FILE, tdfm==1?"compile-time":"runtime");
     else if (verbose >= 1) $display("XTB: Reading test data file \"%0s\" ", TDATA_FILE);
     $readmemb(TDATA_FILE, memall);
   end
    endtask

   task measure_chain_out;
     input reg [NCHAINS-1:0] chid;
     integer bi, errshown, patoff, prefo;
     integer tsc;
     reg [0:MAXCHLEN-1] UNLM;
   begin
     tsc = 0;
     prefo = 0;
     UNLM = ~('b0);
     if (rt_ops[7] != -1 && cur_pat <= (first_pat)) disable measure_chain_out;
     CHAINOUT[0] = (CHAINOUT0);
     CHAINOUT[1] = (CHAINOUT1);
     CHAINOUT[2] = (CHAINOUT2);
     CHAINOUT[3] = (CHAINOUT3);
     UNL = UNLOAD[chid] << prefo;
     CHOUT = CHAINOUT[chid] ^ CH_OUTINV[chid] ^ CT_OUTINV[chid];

     for (bi = 0; bi < MAXCHLEN; bi = bi + 1)
       if (UNL[bi] === 1'bx) UNLM[bi] = 1'b0;

     for (bi = 0; bi < prefo; bi = bi + 1) UNLM[MAXCHLEN-1-bi] = 1'b0;

     if ((UNL&UNLM) !== (CHOUT&UNLM)) begin
       patoff = (loads > 1 || cur_pat <= 0) ? 0 : 1;
     if (cur_pat <= 0 || cur_pat == last_pat && loads > 1) begin
       $display(">>>  Error during scan pattern %0d %s", (cur_pat<0)?0:cur_pat, (cur_pat==last_pat)?"(detected from final parallel pattern unload)":"");
     end
     else begin
       if (loads > 1) $display(">>>  Error during scan pattern %0d (detected from %0d parallel load/unload)", cur_pat, loads);
       else begin $display(">>>  Error during scan pattern %0d (detected from parallel unload of pattern %0d)", cur_pat, cur_pat-1); end
     end
       for (bi = 0; bi < MAXCHLEN-prefo; bi=bi + 1) begin
         if ((UNL[bi] !== 1'bx) && (UNL[bi] !== CHOUT[bi])) begin
           $display(">>>  \tAt T=%0t, V=%0d, exp=%b, got=%b, chain %0s, pin %0s, scan cell %0d, cell name %0s", $time, sertmg?v_count+1+bi+prefo:v_count, UNL[bi], CHOUT[bi], CH_NAMES[chid], CH_PINS[chid], bi+prefo+tsc, SC_NAMES[(chid*MAXCHLEN)+(bi+prefo+tsc)]);
           if (diagf) begin 
           if (diagm==2) $fdisplay(diagf, "  C %0s %0d (exp=%b, got=%b) ", CH_PINS[chid], v_count, UNL[bi], CHOUT[bi]);
           else $fdisplay(diagf, "  %0d %0s %0d (exp=%b, got=%b)",
               cur_pat-patoff, CH_PINS[chid], bi+prefo+tsc, UNL[bi], CHOUT[bi]);
           end 
           nbfails = nbfails + 1;
           ->error_ev;
       check_max_error_limit;
          end 
       end  
     end
   end 
   endtask

   task multiclock_capture ; //proc
     input reg [SIG_IDS-1:0] idargs;
     input reg [2*CUM_WIDTH-1:0] valargs;
   begin
     v_count_per_stmt = 0;
     if (verbose >= 2) $display("XTB: Starting proc multiclock_capture..., T=%0t, V=%0d", $time, v_count+1);
     //check_sid_args("multiclock_capture",22'b1, idargs);
     save_context;
     resolve_wft(0);

     assign_val('d`all_inputs , 22'b0000000000000XXXX0X010);
     assign_val('d`all_outputs , 8'b1111XXXX);

     assign_val('d`SCAN_MODE , 2'b00);
     assign_val('d`pll_bypass , 2'b01);
     assign_val('d`pll_reset , 2'b00);

     if (idargs[15] === 1'b1) assign_ival('d`_pi );
     if (idargs[7] === 1'b1) assign_ival('d`SCAN_MODE );
     if (idargs[5] === 1'b1) assign_ival('d`TEST_SE );
     if (idargs[1] === 1'b1) assign_ival('d`TEST_SI1 );
     if (idargs[2] === 1'b1) assign_ival('d`TEST_SI2 );
     if (idargs[3] === 1'b1) assign_ival('d`TEST_SI3 );
     if (idargs[4] === 1'b1) assign_ival('d`TEST_SI4 );
     if (idargs[0] === 1'b1) assign_ival('d`clk );
     if (idargs[8] === 1'b1) assign_ival('d`pll_bypass_2 );
     if (idargs[6] === 1'b1) assign_ival('d`scan_clk );
     if (idargs[9] === 1'b1) assign_ival('d`pll_bypass );
     if (idargs[10] === 1'b1) assign_ival('d`pll_reset );
     if (idargs[17] === 1'b1) assign_ival('d`_po );
     if (idargs[11] === 1'b1) assign_ival('d`TEST_SO1 );
     if (idargs[12] === 1'b1) assign_ival('d`TEST_SO2 );
     if (idargs[13] === 1'b1) assign_ival('d`TEST_SO3 );
     if (idargs[14] === 1'b1) assign_ival('d`TEST_SO4 );
     assign_stmt(the_wft_id);

     restore_context;
   end 
   endtask

   task allclock_capture ; //proc
     input reg [SIG_IDS-1:0] idargs;
     input reg [2*CUM_WIDTH-1:0] valargs;
   begin
     v_count_per_stmt = 0;
     if (verbose >= 2) $display("XTB: Starting proc allclock_capture..., T=%0t, V=%0d", $time, v_count+1);
     //check_sid_args("allclock_capture",22'b1, idargs);
     save_context;
     resolve_wft(1);

     assign_val('d`all_inputs , 22'b0000000000000XXXX0X010);
     assign_val('d`all_outputs , 8'b1111XXXX);

     assign_val('d`SCAN_MODE , 2'b00);
     assign_val('d`pll_bypass , 2'b01);
     assign_val('d`pll_reset , 2'b00);

     if (idargs[15] === 1'b1) assign_ival('d`_pi );
     if (idargs[7] === 1'b1) assign_ival('d`SCAN_MODE );
     if (idargs[5] === 1'b1) assign_ival('d`TEST_SE );
     if (idargs[1] === 1'b1) assign_ival('d`TEST_SI1 );
     if (idargs[2] === 1'b1) assign_ival('d`TEST_SI2 );
     if (idargs[3] === 1'b1) assign_ival('d`TEST_SI3 );
     if (idargs[4] === 1'b1) assign_ival('d`TEST_SI4 );
     if (idargs[0] === 1'b1) assign_ival('d`clk );
     if (idargs[8] === 1'b1) assign_ival('d`pll_bypass_2 );
     if (idargs[6] === 1'b1) assign_ival('d`scan_clk );
     if (idargs[9] === 1'b1) assign_ival('d`pll_bypass );
     if (idargs[10] === 1'b1) assign_ival('d`pll_reset );
     if (idargs[17] === 1'b1) assign_ival('d`_po );
     if (idargs[11] === 1'b1) assign_ival('d`TEST_SO1 );
     if (idargs[12] === 1'b1) assign_ival('d`TEST_SO2 );
     if (idargs[13] === 1'b1) assign_ival('d`TEST_SO3 );
     if (idargs[14] === 1'b1) assign_ival('d`TEST_SO4 );
     assign_stmt(the_wft_id);

     restore_context;
   end 
   endtask

   task allclock_launch ; //proc
     input reg [SIG_IDS-1:0] idargs;
     input reg [2*CUM_WIDTH-1:0] valargs;
   begin
     v_count_per_stmt = 0;
     if (verbose >= 2) $display("XTB: Starting proc allclock_launch..., T=%0t, V=%0d", $time, v_count+1);
     //check_sid_args("allclock_launch",22'b1, idargs);
     save_context;
     resolve_wft(2);

     assign_val('d`all_inputs , 22'b0000000000000XXXX0X010);
     assign_val('d`all_outputs , 8'b1111XXXX);

     assign_val('d`SCAN_MODE , 2'b00);
     assign_val('d`pll_bypass , 2'b01);
     assign_val('d`pll_reset , 2'b00);

     if (idargs[15] === 1'b1) assign_ival('d`_pi );
     if (idargs[7] === 1'b1) assign_ival('d`SCAN_MODE );
     if (idargs[5] === 1'b1) assign_ival('d`TEST_SE );
     if (idargs[1] === 1'b1) assign_ival('d`TEST_SI1 );
     if (idargs[2] === 1'b1) assign_ival('d`TEST_SI2 );
     if (idargs[3] === 1'b1) assign_ival('d`TEST_SI3 );
     if (idargs[4] === 1'b1) assign_ival('d`TEST_SI4 );
     if (idargs[0] === 1'b1) assign_ival('d`clk );
     if (idargs[8] === 1'b1) assign_ival('d`pll_bypass_2 );
     if (idargs[6] === 1'b1) assign_ival('d`scan_clk );
     if (idargs[9] === 1'b1) assign_ival('d`pll_bypass );
     if (idargs[10] === 1'b1) assign_ival('d`pll_reset );
     if (idargs[17] === 1'b1) assign_ival('d`_po );
     if (idargs[11] === 1'b1) assign_ival('d`TEST_SO1 );
     if (idargs[12] === 1'b1) assign_ival('d`TEST_SO2 );
     if (idargs[13] === 1'b1) assign_ival('d`TEST_SO3 );
     if (idargs[14] === 1'b1) assign_ival('d`TEST_SO4 );
     assign_stmt(the_wft_id);

     restore_context;
   end 
   endtask

   task allclock_launch_capture ; //proc
     input reg [SIG_IDS-1:0] idargs;
     input reg [2*CUM_WIDTH-1:0] valargs;
   begin
     v_count_per_stmt = 0;
     if (verbose >= 2) $display("XTB: Starting proc allclock_launch_capture..., T=%0t, V=%0d", $time, v_count+1);
     //check_sid_args("allclock_launch_capture",22'b1, idargs);
     save_context;
     resolve_wft(3);

     assign_val('d`all_inputs , 22'b0000000000000XXXX0X010);
     assign_val('d`all_outputs , 8'b1111XXXX);

     assign_val('d`SCAN_MODE , 2'b00);
     assign_val('d`pll_bypass , 2'b01);
     assign_val('d`pll_reset , 2'b00);

     if (idargs[15] === 1'b1) assign_ival('d`_pi );
     if (idargs[7] === 1'b1) assign_ival('d`SCAN_MODE );
     if (idargs[5] === 1'b1) assign_ival('d`TEST_SE );
     if (idargs[1] === 1'b1) assign_ival('d`TEST_SI1 );
     if (idargs[2] === 1'b1) assign_ival('d`TEST_SI2 );
     if (idargs[3] === 1'b1) assign_ival('d`TEST_SI3 );
     if (idargs[4] === 1'b1) assign_ival('d`TEST_SI4 );
     if (idargs[0] === 1'b1) assign_ival('d`clk );
     if (idargs[8] === 1'b1) assign_ival('d`pll_bypass_2 );
     if (idargs[6] === 1'b1) assign_ival('d`scan_clk );
     if (idargs[9] === 1'b1) assign_ival('d`pll_bypass );
     if (idargs[10] === 1'b1) assign_ival('d`pll_reset );
     if (idargs[17] === 1'b1) assign_ival('d`_po );
     if (idargs[11] === 1'b1) assign_ival('d`TEST_SO1 );
     if (idargs[12] === 1'b1) assign_ival('d`TEST_SO2 );
     if (idargs[13] === 1'b1) assign_ival('d`TEST_SO3 );
     if (idargs[14] === 1'b1) assign_ival('d`TEST_SO4 );
     assign_stmt(the_wft_id);

     restore_context;
   end 
   endtask

   task load_unload ; //proc
     input reg [SIG_IDS-1:0] idargs;
     input reg [2*CUM_WIDTH-1:0] valargs;
   begin
     v_count_per_stmt = 0;
     if (verbose >= 2) $display("XTB: Starting proc load_unload..., T=%0t, V=%0d", $time, v_count+1);

     if (xtb_sim_mode == 0 && ser_pats > 0 && cur_pat < last_pat && cur_pat == (ser_pats+first_pat)) begin
       $display("XTB: Switching into Parallel simulation mode at pattern %0d (using %0d serial shifts)", cur_pat, SSHIFTS);
       xtb_sim_mode = 1; 
     end
     if (cur_pat != prev_pat) begin
       loads = 1;
       prev_pat = cur_pat;
       if (cur_pat % rep_pat == 0)
         $display("XTB: Begin %0s scan load for pattern %0d (T=%0t, V=%0d)", xtb_sim_mode?"parallel":"serial", cur_pat, $time, v_count+1);
     end
     else begin
       loads = loads + 1;
       if (cur_pat % rep_pat == 0)
         $display("XTB: Begin %0s scan load for pattern %0d, unload %0d (T=%0t, V=%0d)", xtb_sim_mode?"parallel":"serial", cur_pat, loads, $time, v_count+1);
     end
     save_context;
     resolve_wft(4);

     assign_val('d`SCAN_MODE , 2'b00);
     assign_val('d`TEST_SE , 2'b00);
     assign_val('d`TEST_SI1 , 2'b0X);
     assign_val('d`TEST_SI2 , 2'b0X);
     assign_val('d`TEST_SI3 , 2'b0X);
     assign_val('d`TEST_SI4 , 2'b0X);
     assign_val('d`clk , 2'b00);
     assign_val('d`pll_bypass_2 , 2'b0X);
     assign_val('d`scan_clk , 2'b00);
     assign_val('d`TEST_SO1 , 2'b1X);
     assign_val('d`TEST_SO2 , 2'b1X);
     assign_val('d`TEST_SO3 , 2'b1X);
     assign_val('d`TEST_SO4 , 2'b1X);
     assign_val('d`pll_bypass , 2'b01);
     assign_val('d`pll_reset , 2'b00);

     assign_val('d`TEST_SE , 2'b01);
     assign_stmt(the_wft_id);

     if (xtb_sim_mode)      p_shift_0(idargs, valargs);
     else      shift_0(idargs, valargs, 0, 1);

     restore_context;
   end 
   endtask

   task shift_0 ; // load_unload
     input reg [SIG_IDS-1:0] idargs;
     input reg [2*CUM_WIDTH-1:0] valargs;
     input integer stsci;
     input reg stroben;
   begin
    csci = stsci+0; prev_error = -2;
    while (csci < 91) begin
     fsci = csci;
     if (verbose >= 2) $display("XTB: shift %0d, at %0t ", csci, $time);
     resolve_wft(4);
     assign_val('d`_clk , 4'bZZ11);
         if (idargs[1] === 1'b1) begin 
           LOD=LOAD[0]; assign_val('d`TEST_SI1 , {1'b0, LOD[csci+0]});
         end
         if (idargs[2] === 1'b1) begin 
           LOD=LOAD[1]; assign_val('d`TEST_SI2 , {1'b0, LOD[csci+0]});
         end
         if (idargs[3] === 1'b1) begin 
           LOD=LOAD[2]; assign_val('d`TEST_SI3 , {1'b0, LOD[csci+0]});
         end
         if (idargs[4] === 1'b1) begin 
           LOD=LOAD[3]; assign_val('d`TEST_SI4 , {1'b0, LOD[csci+0]});
         end
         if(stroben && idargs[11] === 1'b1) begin 
           UNL = UNLOAD[0]; assign_val('d`TEST_SO1 , {1'b1,  UNL[csci+0]});
         end
         if(stroben && idargs[12] === 1'b1) begin 
           UNL = UNLOAD[1]; assign_val('d`TEST_SO2 , {1'b1,  UNL[csci+0]});
         end
         if(stroben && idargs[13] === 1'b1) begin 
           UNL = UNLOAD[2]; assign_val('d`TEST_SO3 , {1'b1,  UNL[csci+0]});
         end
         if(stroben && idargs[14] === 1'b1) begin 
           UNL = UNLOAD[3]; assign_val('d`TEST_SO4 , {1'b1,  UNL[csci+0]});
         end
     assign_stmt(the_wft_id);
     csci = csci+1;
    end
   end
   endtask


   always /* ParallelShiftMode */ @(strobe_scells) begin
     CHAINOUT0[0:31] = {`XTB_DUT_HIER.DU.dm.\memory_reg[5][10] .Q , `XTB_DUT_HIER.DU.dm.\memory_reg[5][9] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[5][8] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[5][7] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[5][6] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[5][5] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[5][4] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[5][3] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[5][2] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[5][1] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[5][0] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[4][15] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[4][14] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[4][13] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[4][12] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[4][11] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[4][10] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[4][9] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[4][8] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[4][7] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[4][6] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[4][5] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[4][4] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[4][3] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[4][2] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[4][1] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[4][0] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[3][15] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[3][14] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[3][13] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[3][12] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[3][11] .QN };
     CHAINOUT0[32:63] = {`XTB_DUT_HIER.DU.dm.\memory_reg[3][10] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[3][9] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[3][8] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[3][7] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[3][6] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[3][5] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[3][4] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[3][3] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[3][2] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[3][1] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[3][0] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[2][15] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[2][14] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[2][13] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[2][12] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[2][11] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[2][10] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[2][9] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[2][8] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[2][7] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[2][6] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[2][5] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[2][4] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[2][3] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[2][2] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[2][1] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[2][0] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[1][15] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[1][14] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[1][13] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[1][12] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[1][11] .QN };
     CHAINOUT0[64:90] = {`XTB_DUT_HIER.DU.dm.\memory_reg[1][10] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[1][9] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[1][8] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[1][7] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[1][6] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[1][5] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[1][4] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[1][3] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[1][2] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[1][1] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[1][0] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[0][15] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[0][14] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[0][13] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[0][12] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[0][11] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[0][10] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[0][9] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[0][8] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[0][7] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[0][6] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[0][5] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[0][4] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[0][3] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[0][2] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[0][1] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[0][0] .QN };
   end

		
   always /* ParallelShiftMode */ @(strobe_scells) begin
     CHAINOUT1[0:31] = {`XTB_DUT_HIER.snps_clk_chain_0.\U_shftreg_0/ff_0/q_reg .Q , `XTB_DUT_HIER.snps_clk_chain_0.\U_shftreg_0/ff_1/q_reg .Q , `XTB_DUT_HIER.snps_clk_chain_0.\U_shftreg_0/ff_2/q_reg .Q , `XTB_DUT_HIER.snps_clk_chain_0.\U_shftreg_0/ff_3/q_reg .Q , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 };
     CHAINOUT1[32:63] = {1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 };
     CHAINOUT1[64:90] = {1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 , 1'b0 };
   end

   always /* ParallelShiftMode */ @(strobe_scells) begin
     CHAINOUT2[0:31] = {`XTB_DUT_HIER.DU.reg_file.\reg_array_reg[2][5] .Q , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[2][4] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[2][3] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[2][2] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[2][1] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[2][0] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[1][15] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[1][14] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[1][13] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[1][12] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[1][11] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[1][10] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[1][9] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[1][8] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[1][7] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[1][6] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[1][5] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[1][4] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[1][3] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[1][2] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[1][1] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[1][0] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[0][15] .Q , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[0][14] .Q , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[0][13] .Q , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[0][12] .Q , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[0][11] .Q , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[0][10] .Q , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[0][9] .Q , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[0][8] .Q , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[0][7] .Q , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[0][6] .Q };
     CHAINOUT2[32:63] = {`XTB_DUT_HIER.DU.reg_file.\reg_array_reg[0][5] .Q , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[0][4] .Q , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[0][3] .Q , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[0][2] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[0][1] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[0][0] .QN , `XTB_DUT_HIER.DU.\pc_current_reg[15] .QN , `XTB_DUT_HIER.DU.\pc_current_reg[14] .QN , `XTB_DUT_HIER.DU.\pc_current_reg[13] .QN , `XTB_DUT_HIER.DU.\pc_current_reg[12] .QN , `XTB_DUT_HIER.DU.\pc_current_reg[11] .QN , `XTB_DUT_HIER.DU.\pc_current_reg[10] .QN , `XTB_DUT_HIER.DU.\pc_current_reg[9] .QN , `XTB_DUT_HIER.DU.\pc_current_reg[8] .QN , `XTB_DUT_HIER.DU.\pc_current_reg[7] .QN , `XTB_DUT_HIER.DU.\pc_current_reg[6] .QN , `XTB_DUT_HIER.DU.\pc_current_reg[5] .QN , `XTB_DUT_HIER.DU.\pc_current_reg[4] .QN , `XTB_DUT_HIER.DU.\pc_current_reg[3] .QN , `XTB_DUT_HIER.DU.\pc_current_reg[2] .QN , `XTB_DUT_HIER.DU.\pc_current_reg[1] .QN , `XTB_DUT_HIER.DU.\pc_current_reg[0] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[7][15] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[7][14] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[7][13] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[7][12] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[7][11] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[7][10] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[7][9] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[7][8] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[7][7] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[7][6] .QN };
     CHAINOUT2[64:90] = {`XTB_DUT_HIER.DU.dm.\memory_reg[7][5] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[7][4] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[7][3] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[7][2] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[7][1] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[7][0] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[6][15] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[6][14] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[6][13] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[6][12] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[6][11] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[6][10] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[6][9] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[6][8] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[6][7] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[6][6] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[6][5] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[6][4] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[6][3] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[6][2] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[6][1] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[6][0] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[5][15] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[5][14] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[5][13] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[5][12] .QN , `XTB_DUT_HIER.DU.dm.\memory_reg[5][11] .QN };
   end

   always /* ParallelShiftMode */ @(strobe_scells) begin
     CHAINOUT3[0:31] = {`XTB_DUT_HIER.DU.reg_file.\reg_array_reg[7][15] .Q , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[7][14] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[7][13] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[7][12] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[7][11] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[7][10] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[7][9] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[7][8] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[7][7] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[7][6] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[7][5] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[7][4] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[7][3] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[7][2] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[7][1] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[7][0] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[6][15] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[6][14] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[6][13] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[6][12] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[6][11] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[6][10] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[6][9] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[6][8] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[6][7] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[6][6] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[6][5] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[6][4] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[6][3] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[6][2] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[6][1] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[6][0] .QN };
     CHAINOUT3[32:63] = {`XTB_DUT_HIER.DU.reg_file.\reg_array_reg[5][15] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[5][14] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[5][13] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[5][12] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[5][11] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[5][10] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[5][9] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[5][8] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[5][7] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[5][6] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[5][5] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[5][4] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[5][3] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[5][2] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[5][1] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[5][0] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[4][15] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[4][14] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[4][13] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[4][12] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[4][11] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[4][10] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[4][9] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[4][8] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[4][7] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[4][6] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[4][5] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[4][4] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[4][3] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[4][2] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[4][1] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[4][0] .QN };
     CHAINOUT3[64:90] = {`XTB_DUT_HIER.DU.reg_file.\reg_array_reg[3][15] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[3][14] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[3][13] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[3][12] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[3][11] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[3][10] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[3][9] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[3][8] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[3][7] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[3][6] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[3][5] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[3][4] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[3][3] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[3][2] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[3][1] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[3][0] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[2][15] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[2][14] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[2][13] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[2][12] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[2][11] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[2][10] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[2][9] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[2][8] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[2][7] .QN , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[2][6] .QN , 1'b0 };
   end

   `define CELL0IN0 `XTB_DUT_HIER.DU.dm.\memory_reg[0][0] .SI
   `define CELL0IN1 `XTB_DUT_HIER.snps_clk_chain_0.\U_shftreg_0/ff_3/q_reg .D
   `define CELL0IN2 `XTB_DUT_HIER.DU.dm.\memory_reg[5][11] .SI
   `define CELL0IN3 `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[2][6] .SI
   `define CHAININ0 {`XTB_DUT_HIER.DU.dm.\memory_reg[5][10] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[5][9] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[5][8] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[5][7] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[5][6] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[5][5] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[5][4] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[5][3] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[5][2] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[5][1] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[5][0] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[4][15] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[4][14] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[4][13] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[4][12] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[4][11] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[4][10] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[4][9] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[4][8] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[4][7] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[4][6] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[4][5] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[4][4] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[4][3] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[4][2] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[4][1] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[4][0] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[3][15] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[3][14] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[3][13] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[3][12] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[3][11] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[3][10] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[3][9] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[3][8] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[3][7] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[3][6] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[3][5] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[3][4] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[3][3] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[3][2] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[3][1] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[3][0] .SI , \
	`XTB_DUT_HIER.DU.dm.\memory_reg[2][15] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[2][14] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[2][13] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[2][12] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[2][11] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[2][10] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[2][9] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[2][8] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[2][7] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[2][6] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[2][5] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[2][4] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[2][3] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[2][2] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[2][1] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[2][0] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[1][15] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[1][14] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[1][13] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[1][12] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[1][11] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[1][10] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[1][9] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[1][8] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[1][7] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[1][6] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[1][5] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[1][4] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[1][3] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[1][2] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[1][1] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[1][0] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[0][15] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[0][14] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[0][13] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[0][12] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[0][11] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[0][10] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[0][9] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[0][8] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[0][7] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[0][6] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[0][5] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[0][4] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[0][3] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[0][2] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[0][1] .SI ,  `CELL0IN0 }

   `define CHAININ1 {`XTB_DUT_HIER.snps_clk_chain_0.\U_shftreg_0/ff_0/q_reg .D , `XTB_DUT_HIER.snps_clk_chain_0.\U_shftreg_0/ff_1/q_reg .D , `XTB_DUT_HIER.snps_clk_chain_0.\U_shftreg_0/ff_2/q_reg .D ,  `CELL0IN1 }

   `define CHAININ2 {`XTB_DUT_HIER.DU.reg_file.\reg_array_reg[2][5] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[2][4] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[2][3] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[2][2] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[2][1] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[2][0] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[1][15] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[1][14] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[1][13] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[1][12] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[1][11] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[1][10] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[1][9] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[1][8] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[1][7] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[1][6] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[1][5] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[1][4] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[1][3] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[1][2] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[1][1] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[1][0] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[0][15] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[0][14] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[0][13] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[0][12] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[0][11] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[0][10] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[0][9] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[0][8] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[0][7] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[0][6] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[0][5] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[0][4] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[0][3] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[0][2] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[0][1] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[0][0] .SI , `XTB_DUT_HIER.DU.\pc_current_reg[15] .SI , `XTB_DUT_HIER.DU.\pc_current_reg[14] .SI , `XTB_DUT_HIER.DU.\pc_current_reg[13] .SI , `XTB_DUT_HIER.DU.\pc_current_reg[12] .SI , `XTB_DUT_HIER.DU.\pc_current_reg[11] .SI , \
	`XTB_DUT_HIER.DU.\pc_current_reg[10] .SI , `XTB_DUT_HIER.DU.\pc_current_reg[9] .SI , `XTB_DUT_HIER.DU.\pc_current_reg[8] .SI , `XTB_DUT_HIER.DU.\pc_current_reg[7] .SI , `XTB_DUT_HIER.DU.\pc_current_reg[6] .SI , `XTB_DUT_HIER.DU.\pc_current_reg[5] .SI , `XTB_DUT_HIER.DU.\pc_current_reg[4] .SI , `XTB_DUT_HIER.DU.\pc_current_reg[3] .SI , `XTB_DUT_HIER.DU.\pc_current_reg[2] .SI , `XTB_DUT_HIER.DU.\pc_current_reg[1] .SI , `XTB_DUT_HIER.DU.\pc_current_reg[0] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[7][15] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[7][14] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[7][13] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[7][12] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[7][11] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[7][10] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[7][9] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[7][8] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[7][7] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[7][6] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[7][5] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[7][4] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[7][3] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[7][2] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[7][1] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[7][0] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[6][15] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[6][14] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[6][13] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[6][12] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[6][11] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[6][10] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[6][9] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[6][8] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[6][7] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[6][6] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[6][5] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[6][4] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[6][3] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[6][2] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[6][1] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[6][0] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[5][15] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[5][14] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[5][13] .SI , `XTB_DUT_HIER.DU.dm.\memory_reg[5][12] .SI ,  `CELL0IN2 }

   `define CHAININ3 {`XTB_DUT_HIER.DU.reg_file.\reg_array_reg[7][15] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[7][14] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[7][13] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[7][12] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[7][11] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[7][10] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[7][9] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[7][8] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[7][7] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[7][6] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[7][5] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[7][4] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[7][3] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[7][2] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[7][1] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[7][0] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[6][15] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[6][14] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[6][13] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[6][12] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[6][11] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[6][10] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[6][9] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[6][8] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[6][7] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[6][6] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[6][5] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[6][4] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[6][3] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[6][2] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[6][1] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[6][0] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[5][15] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[5][14] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[5][13] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[5][12] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[5][11] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[5][10] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[5][9] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[5][8] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[5][7] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[5][6] .SI , \
	`XTB_DUT_HIER.DU.reg_file.\reg_array_reg[5][5] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[5][4] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[5][3] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[5][2] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[5][1] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[5][0] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[4][15] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[4][14] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[4][13] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[4][12] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[4][11] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[4][10] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[4][9] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[4][8] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[4][7] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[4][6] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[4][5] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[4][4] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[4][3] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[4][2] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[4][1] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[4][0] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[3][15] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[3][14] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[3][13] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[3][12] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[3][11] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[3][10] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[3][9] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[3][8] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[3][7] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[3][6] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[3][5] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[3][4] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[3][3] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[3][2] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[3][1] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[3][0] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[2][15] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[2][14] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[2][13] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[2][12] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[2][11] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[2][10] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[2][9] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[2][8] .SI , `XTB_DUT_HIER.DU.reg_file.\reg_array_reg[2][7] .SI ,  `CELL0IN3 }


   task p_shift_0 ;
     input reg [SIG_IDS-1:0] idargs;
     input reg [2*CUM_WIDTH-1:0] valargs;
     integer i, j;
   begin
     if (~(idargs[18] | idargs[1] | idargs[2] | idargs[3] | idargs[4] | idargs[21] | idargs[11] | idargs[12] | idargs[13] | idargs[14] )) 
       disable p_shift_0 ; 
     if (SSHIFTS < MAXCHLEN) begin
         if (verbose >= 2) $display("XTB: (parallel) shift, at %0t  ", $time);
         resolve_wft(4);
     fork 
       begin: b1 
         #40 ;
         -> strobe_scells;
         repeat (SYNC_LATENCY) #0;
         if (idargs[11] === 1'b1) begin 
           measure_chain_out('d0);
         end
         if (idargs[12] === 1'b1) begin 
           measure_chain_out('d1);
         end
         if (idargs[13] === 1'b1) begin 
           measure_chain_out('d2);
         end
         if (idargs[14] === 1'b1) begin 
           measure_chain_out('d3);
         end
         if (idargs[1] === 1'b1) begin
           LOD0=(LOAD[0] >> SSHIFTS) ^ CH_INPINV[0];
         end
         if (idargs[2] === 1'b1) begin
           LOD1=(LOAD[1] >> SSHIFTS) ^ CH_INPINV[1];
         end
         if (idargs[3] === 1'b1) begin
           LOD2=(LOAD[2] >> SSHIFTS) ^ CH_INPINV[2];
         end
         if (idargs[4] === 1'b1) begin
           LOD3=(LOAD[3] >> SSHIFTS) ^ CH_INPINV[3];
         end

           ->force_scells; 
         #0;
       end 
       begin: b2
         assign_val('d`_clk , 4'bZZ11);
         assign_stmt(the_wft_id);
       end 
     join 

     ->release_scells; //aa

         #0;
         if (sertmg == 1) begin
           v_count = v_count + PARSERINC - SSHIFTS - 1;
           for (i = 0; i < PARSERINC - SSHIFTS - 1; i = i+1)
             complete_cycle(the_wft_id);
         end
         if (SSHIFTS > 0) shift_0(idargs, valargs, MAXCHLEN-SSHIFTS, 0) ; 

     end 
     else begin 
         shift_0(idargs, valargs, 0, 1);
     end
   end
   endtask


   always /* ParallelShiftMode */ @(force_scells) begin 
           force `CHAININ0 = LOD0;
           force `CHAININ1 = LOD1;
           force `CHAININ2 = LOD2;
           force `CHAININ3 = LOD3;

   end


   always /* ParallelShiftMode */ @(release_scells) begin 
     release `CHAININ0;  release `CHAININ1;  release `CHAININ2;  release `CHAININ3; 
   end
   task skip_n_pat ; 
     input integer fpat; 
     integer cond ;
     integer nargs; 
    begin 
       cond = 1;
       while ( cond == 1 && cur_pat < fpat) begin
         memel = memall[data_i];
         opcode = memel[15:0];
         nargs = memel[20:16];
         if(  opcode == `WFTStmt || opcode == `SetForceSI || opcode == `EndGenLoopStmt || opcode == `GenLoopStmt || opcode == `SetValidStrobe || opcode == `SetLastReseed )begin  data_i = data_i -1 ; cond = 0; end 
         else if ( opcode == `IncPat || opcode == `SetPat) begin
           cur_pat = (opcode == `SetPat)?memel[43:16] :cur_pat + 1 ;
           if(fpat-1 > cur_pat) data_i = data_i + 1 ;
           else cond = 0 ;
         end
          else begin 
           nargs = nargs==0?1:nargs+1 ;
           data_i = data_i + nargs ;
         end
       end
    end
   endtask


   always @(start_part) begin: Internal_scan_occ_bypass_pattern__proc_unit

     integer nbpats, i;
     integer nargs, na;
     integer args;

     integer tdf;
     nbpats = 0; cur_pat = -1;
     loads = 1;

     end_pat = 0; v_count = 0; v_count_per_pat = 0; v_count_per_stmt = 0;
     nbfails = 0;
     prev_pat = -2; prev_error = -2; first_pat = 0;
     diagf = 0;
     if ( $value$plusargs ("tmax_diag_file=%s", diag_file )) diagm = diagm ? diagm : 1;
     if ( $value$plusargs ("tmax_test_data_file=%s", TDATA_FILE )) tdfm = 2;
     read_data;
     data_i = 1; 
     popcode = 'd0;

     if (diagm > 0) begin
       if (diagm > 2) begin
         $display("XTB Warning: wrong diagnosis mode (%0d), using default mode 1 (pattern based)", diagm);
         diagm = 1 ; 
       end  
       if ( $value$plusargs ("tmax_diag_file=%s", diag_file )) begin
         $display("XTB: Setting run-time option \"tmax_diag_file\" to %0s .",diag_file);
       end 
       else begin
         `ifdef tmax_diag_file 
         diag_file = `tmax_diag_file;
         `else  diag_file = "PATTERNS/MAXTB/Risc_16_bit_TF_Internal_scan_parallel_max_tb.diag"; 
         `endif 
       end
       diagf = $fopen(diag_file);
       if (diagf == 0) begin
         $display("XTB Error: Unable to open diagnosis file %s (for writing). Exiting...", diag_file);
         $finish; 
       end
       if (verbose >= 1) $display("XTB: User requesting TetraMAX compliant diagnosis file: %0s", diag_file);
       $fdisplay(diagf, "// Serial scan error:       <pat#> \t<pin_name> \t<shift_index> \t(<expected_value> <simulated_value>)");
       $fdisplay(diagf, "// USF Parallel scan error: <pat#> \t<pin_name> \t<shift_index> \t(<expected_value> <simulated_value>)");
       $fdisplay(diagf, "// DSF Parallel scan error: <pat#> \t<chain_name> \t<cell_index> \t(<expected_value> <simulated_value>)");
       $fdisplay(diagf, "// Capture error:           <pat#> \t<pin_name> \t(<expected_value> <simulated_value>)");
       $fdisplay(diagf, "// Cycle based error:          C \t<pin_name> \t<vect_nbr> \t(<expected_value> <simulated_value>)\n\n");

     end 

     memel = memall[data_i]; 
     total_pats = memel[31:0];
     data_i=data_i+1;
     memel = memall[data_i];
     if(memel != `SIGCODE) begin
       $display("XTB Error: test data file %0s does not macth with testbench file. Exiting...", TDATA_FILE);
       $display("           (please check that the test data file is generated from the right STIL file).");
       $finish; 
     end 
     data_i = data_i+1;

     if (tdfm > 0) begin
      if (memall[data_i] > MDEPTH) begin
       $display("XTB Error: size of test data file %0s exceeding testbench memory allocation. Exiting...", TDATA_FILE);
       $display("           (please recompile using -pvalue+Risc_16_bit_test.MDEPTH=%0d).\n", memall[data_i]);
       $finish; 
      end
     end
      data_i = data_i+1; 

     last_pat = -1;

     n_pat_sim = -1;

     start_pat = -1;

     if (total_pats < 0 || |(total_pats) === 1'bx) begin
       $display("XTB Error: Inconsistent total number of patterns (%d). Exiting...",  total_pats);
       $finish;
     end

     if (verbose >= 1) $display("XTB: Total number of patterns  %0d",  total_pats); 
     if (last_pat == -1) last_pat = total_pats - 1;

     `ifdef tmax_n_pattern_sim
     last_pat=`tmax_n_pattern_sim;
     n_pat_sim=`tmax_n_pattern_sim;
     `endif

     `ifdef tmax_test_setup_only_once
     test_setup_only_once = 1;
     `endif

     `ifdef tmax_test_setup_mode
     test_setup_mode = `tmax_test_setup_mode;
     `endif

     xtb_sim_mode = 1;
     SSHIFTS = DFSHIFTS;

     ser_pats = 0;
     csim_op = -1;

     `ifdef tmax_serial
       if (~(`tmax_serial & 1'b1) == 1'b0) 
         ser_pats = last_pat + 1;
       else 
         ser_pats = `tmax_serial + 0;
       if (ser_pats > 0)
       csim_op = 0;
       `ifdef tmax_parallel 
         if (~(`tmax_parallel & 1'b1) == 1'b0) SSHIFTS = DFSHIFTS;
         else SSHIFTS = `tmax_parallel + 0; 
         if (ser_pats  >= last_pat + 1) begin	 
           csim_op = 2; 
         end 
         else if (ser_pats == 0)
           csim_op = 1;
       `endif
     `else 
       `ifdef tmax_parallel
         csim_op = 1;
         if (~(`tmax_parallel & 1'b1) == 1'b0) SSHIFTS = DFSHIFTS;
         else SSHIFTS = `tmax_parallel + 0; 
       `endif 
     `endif
     if (SSHIFTS < 0) begin
       $display("XTB Error: Passing negative value (%0d) of serial shifts in parallel mode. Exiting...",  SSHIFTS);
       $finish; 
     end

     process_rtops;
     `ifdef tmax_serial_timing 
       sertmg = 1;
       if (xtb_sim_mode == 1) $display("XTB: Parallel simulation (timing and vector) extended to match serial simulation");
     `else 
       sertmg = 0; 
     `endif


     $display("XTB: Starting %0s simulation of %0d pattern%s", xtb_sim_mode == 0 ? "serial" : "parallel", xtb_sim_mode == 0 ? ((ser_pats>last_pat || ser_pats==0)?(last_pat+1):ser_pats): last_pat + 1, (xtb_sim_mode!=0 || ser_pats>1)?"s":"");
     if (xtb_sim_mode) begin 
       $display("XTB: Using %0d serial shifts", SSHIFTS);
     end

     if (SSHIFTS >= MAXCHLEN)  begin 
       $display("XTB Warning: serial shifts (%0d) equals or exceeds max chain length (%0d). Performing full serial scan... ", SSHIFTS, MAXCHLEN); 
       xtb_sim_mode = 0;	
     end 

     if (diagm==2 && xtb_sim_mode==1)  begin 
       $display("XTB Warning: cannot display cycle-based diagnostic messages in parallel load mode simulation. Simulation will display pattern-based diagnostic messages."); 
       diagm = 1;	
     end 

     if (test_setup_mode == 2) begin
       if ($fopen("PATTERNS/MAXTB/Risc_16_bit_TF_Internal_scan_parallel_max_tb_test_setup.save", "r") == 0) begin
         $display("XTB Error: Cannot find file \"PATTERNS/MAXTB/Risc_16_bit_TF_Internal_scan_parallel_max_tb_test_setup.save\" (previous test_setup simulation)");
         $display("           Please generate first file \"PATTERNS/MAXTB/Risc_16_bit_TF_Internal_scan_parallel_max_tb_test_setup.save\" using tmax_test_setup_mode=1. Exiting...");
         $finish(0); 
       end
       else begin
         $display("XTB: Restarting simulation from file \"PATTERNS/MAXTB/Risc_16_bit_TF_Internal_scan_parallel_max_tb_test_setup.save\" (previous test_setup simulation)");
         $restart ("PATTERNS/MAXTB/Risc_16_bit_TF_Internal_scan_parallel_max_tb_test_setup.save"); 
       end 
     end 
     while (cur_pat <= last_pat && end_pat != 1) begin : CONT_STMT
       memel = memall[data_i];
       opcode = memel[15:0];
       cur_stmt = -1;
       args = 'b0;
       if ((popcode == `EndGenTestSetupStmt) && (test_setup_mode == 1)) begin
         $display("XTB: Stopping simulation and exiting after test_setup (upon user request)...");
         $finish (0); 
       end
       case (opcode)
         'd`EndPat:  begin
                       cur_stmt = `EndPat;
                       end_pat = 1;
                     end
         'd`IncPat:  begin
                       cur_stmt = `IncPat;
                       if (rt_ops[7] != -1 && cur_pat < first_pat ) skip_n_pat(rt_ops[7]); 
                       else cur_pat = cur_pat + 1;
                       v_count_per_pat = 0;
                       nbpats = nbpats+1;

                     end
         'd`SetLastReseed:  begin
                       cur_stmt = `SetLastReseed;
                       `ifdef tmax_fast_reseed
                       set_last_reseed = memel[17:16];
                       `else
                       set_last_reseed = 1;
                       `endif
                     end
         'd`SetValidStrobe:  begin
                       cur_stmt = `SetValidStrobe;
                     end
         'd`SetForceSI:  begin
                       cur_stmt = `SetForceSI;
                     end
         'd`SetPat:  begin
                       cur_stmt = `SetPat;
                       v_count_per_pat = 0;
                       if (cur_pat==-1  && rt_ops[7] == -1) begin first_pat = memel[43:16]; cur_pat = first_pat; end
                       else cur_pat = memel[43:16];
                       if (start_pat==-1) start_pat = memel[43:16];
                       if (rt_ops[7] != -1 && cur_pat < first_pat ) skip_n_pat(rt_ops[7]); 
                       if(rt_ops[4] == -1) last_pat = last_pat + cur_pat; 
                       if (n_pat_sim>0) last_pat = start_pat+n_pat_sim;
                       nbpats = nbpats+1;  
                     end
         'd`WFTStmt: begin
                       cur_stmt = `WFTStmt;
                       resolve_wft(memel[18:16]);
                     end 
         'd`ConditionStmt, 'd`FixedStmt, 'd`VectorStmt: begin
           if (opcode == 'd`ConditionStmt) cur_stmt = 'd`ConditionStmt;
           else 	cur_stmt='d`VectorStmt;
           nargs = memel[20:16];
           na = 0;
           while (na<nargs) begin
             data_i = data_i + 1;
             memel = memall[data_i];
             assign_val(memel[SIG_IDS_W-1:0], memel[2*MAX_WIDTH+SIG_IDS_W-1:SIG_IDS_W]);
             na = na + 1;
           end
           if (opcode == `VectorStmt) assign_stmt(the_wft_id);
          end 
          'd`GenLoopStmt: begin: GenLoop_BLOCK
            cur_stmt = `GenLoopStmt;
            lp_count = 1;
            lp_addr = data_i;
            lp_max = memel[31:16];
            $display("\nXTB: starting loop statement with %0d iterations", lp_max); 
          end 
          'd`EndGenLoopStmt: begin: EndLoop_BLOCK
            cur_stmt = `EndGenLoopStmt;
            $display("\nXTB: loop iteration %0d/%0d done.", lp_count, lp_max);
            lp_count = lp_count+1;
            if (lp_count <= lp_max) begin
              data_i = lp_addr;
            end 
         end 
          'd`GenTestSetupStmt: begin: GenTestSetupStmt_BLOCK
              cur_stmt = `GenTestSetupStmt;
              if (verbose >= 2) $display("XTB: Starting generic test_setup Macro..., T=%0t, V=%0d", $time, v_count+1); 
         end

          'd`EndGenTestSetupStmt: begin: EndGenTestSetupStmt_BLOCK
              cur_stmt = `EndGenTestSetupStmt;
              test_setup_done = 'b1;
              if (verbose >= 2) $display("XTB: End of generic test_setup Macro.");
            if (test_setup_mode == 1 || test_setup_mode == 3) begin
             $display("XTB: Saving simulation state in \"PATTERNS/MAXTB/Risc_16_bit_TF_Internal_scan_parallel_max_tb_test_setup.save\" file %0s", (test_setup_mode == 1)?"and exiting...":"...");
             $save ("PATTERNS/MAXTB/Risc_16_bit_TF_Internal_scan_parallel_max_tb_test_setup.save"); 
             #1;
             if ( $value$plusargs ("tmax_test_data_file=%s", TDATA_FILE )) begin
               tdfm = 2;
               read_data;
             end
             if (test_setup_mode == 1)
               $value$plusargs ("tmax_test_setup_mode=%d", test_setup_mode);
           end  
         end
         'd`multiclock_captureStmt: begin: multiclock_capture_BLOCK
           cur_stmt = `multiclock_captureStmt;
           set_args(memel[20:16]);
             multiclock_capture(sid_args, sval_args);
         end 
         'd`allclock_captureStmt: begin: allclock_capture_BLOCK
           cur_stmt = `allclock_captureStmt;
           set_args(memel[20:16]);
             allclock_capture(sid_args, sval_args);
         end 
         'd`allclock_launchStmt: begin: allclock_launch_BLOCK
           cur_stmt = `allclock_launchStmt;
           set_args(memel[20:16]);
             allclock_launch(sid_args, sval_args);
         end 
         'd`allclock_launch_captureStmt: begin: allclock_launch_capture_BLOCK
           cur_stmt = `allclock_launch_captureStmt;
           set_args(memel[20:16]);
             allclock_launch_capture(sid_args, sval_args);
         end 
         'd`load_unloadStmt: begin: load_unload_BLOCK
           cur_stmt = `load_unloadStmt;
            na = 0; nargs = 'b0; sid_args = 'b0; sval_args = 'b0;
            nargs = memel[20:16];
            while (na < nargs) begin
              data_i = data_i + 1;
              memel = memall[data_i];
              if (memel[SIG_IDS_W-1:0] > SIG_IDS-1) begin
                $display("\nXTB Error: Passing wrong signal ID (%b), valid range is 1..%d. Exiting...", memel[SIG_IDS_W-1:0], SIG_IDS-1);
                $finish;
              end
              sid_args[memel[SIG_IDS_W-1:0]] = 1'b1;
              case (memel[SIG_IDS_W-1:0])
               'd`TEST_SI1: begin LOAD[0] = memel[MAXCHLEN-1+SIG_IDS_W:SIG_IDS_W]; end 
               'd`TEST_SI2: begin LOAD[1] = memel[MAXCHLEN-1+SIG_IDS_W:SIG_IDS_W]; end 
               'd`TEST_SI3: begin LOAD[2] = memel[MAXCHLEN-1+SIG_IDS_W:SIG_IDS_W]; end 
               'd`TEST_SI4: begin LOAD[3] = memel[MAXCHLEN-1+SIG_IDS_W:SIG_IDS_W]; end 
               'd`TEST_SO1: begin UNLOAD[0] = memel[MAXCHLEN-1+SIG_IDS_W:SIG_IDS_W]; end 
               'd`TEST_SO2: begin UNLOAD[1] = memel[MAXCHLEN-1+SIG_IDS_W:SIG_IDS_W]; end 
               'd`TEST_SO3: begin UNLOAD[2] = memel[MAXCHLEN-1+SIG_IDS_W:SIG_IDS_W]; end 
               'd`TEST_SO4: begin UNLOAD[3] = memel[MAXCHLEN-1+SIG_IDS_W:SIG_IDS_W]; end 
               default: begin  
                 $display("\nXTB Error: Wrong signal argument (%0s) passed to load_unload procedure. Exiting...", SignalIDName[memel[SIG_IDS_W-1:0]]);
                 $finish; 
               end 
             endcase 
             na = na+1;
           end
             load_unload(sid_args, sval_args);
         end 
         default: begin $display("\nXTB Error: Unrecognized code %0h, @ inst %0d", opcode, data_i); $finish; end 
       endcase 
       data_i = data_i + 1;
       popcode = opcode;
       if (verbose >= 3) display_stmt(cur_stmt);
     end 
     $display("XTB: Simulation of %0d pattern%s completed with %0d mismatch%s (time: %0t, cycles: %0d)\n", nbpats+end_pat-1, (nbpats==1)?"":"s", nbfails, (nbfails==1)?"":"es", $time, v_count); 

     if (diagf) $fclose(diagf);
     ->end_part;
   end 


   task init_rtops;
     integer i;
   begin
     for (i=0; i<`NBRTOPS; i=i+1)
       rt_ops[i] = -1;
     RT_OPS [4] = "tmax_last_pat";
     RT_OPS [5] = "tmax_n_pattern_sim";
     RT_OPS [8] = "tmax_serial";
     RT_OPS [9] = "tmax_parallel";
     RT_OPS [0] = "tmax_msg";
     RT_OPS [1] = "tmax_rpt";
     RT_OPS [10] = "tmax_test_setup_only_once";
     RT_OPS [11] = "tmax_usf_debug_strobe_mode";
     RT_OPS [6] = "tmax_test_setup_mode";
     RT_OPS [7] = "tmax_first_pat";
     RT_OPS [2] = "tmax_diag_file";
     RT_OPS [3] = "tmax_n_error_stop";
   end 
   endtask

   task process_rtops;
     integer sim_op, p_mode;
     integer i, r;
   begin
     sim_op = -1;
     init_rtops;
     for (i=0; i<`NBRTOPS; i=i+1)
       r = $value$plusargs ({RT_OPS[i], "=%d"}, rt_ops[i]);
     if ((rt_ops[4] > -1))   begin
       last_pat =  rt_ops[4];
         display_ops ((rt_ops[4] > 0), last_pat, RT_OPS[4]);
         $display("XTB: User requesting ending simulation at pattern %0d",last_pat); 
        
     end
     if ((rt_ops[5] > -1)) begin last_pat = rt_ops[5]; n_pat_sim = rt_ops[5]; end
     if (rt_ops[4] == -1 && last_pat != total_pats-1) begin
       display_ops ((rt_ops[5] > 0), last_pat, RT_OPS[5]);
       $display("XTB: User requesting simulation of first %0d patterns", last_pat);
     end 
     if (rt_ops[4] == -1 && last_pat >= total_pats && total_pats > 1) begin
       $display("XTB Warning: Requested simulation patterns (%0d) exceeds total pattern count (%0d). Adjusting...", last_pat+1, total_pats);
       last_pat = total_pats-1;
     end 
     else if (last_pat < 0 && total_pats != 0)  begin 
       $display("XTB Error: User requesting simulating wrong number of patterns (%0d). Exiting... ", last_pat+1);
       $finish;
     end
     if ((rt_ops[8] > 0)) begin
       if (rt_ops[8]==0) ser_pats = last_pat + 1;
       else ser_pats = rt_ops[8];
       sim_op = 0;
     end 
     else if (rt_ops[8] != 0 &&  ($test$plusargs ("tmax_serial"))) begin
       ser_pats = last_pat + 1;
       rt_ops[8] = ser_pats;
       sim_op = 0;
     end
     if ((rt_ops[8]>0) || (csim_op==0 || csim_op==2)) display_ops ((rt_ops[8]>0), ser_pats, RT_OPS[8]);
     p_mode = ((rt_ops[9] > -1) || ($test$plusargs ("tmax_parallel")))?1:0;
     if (p_mode) begin
       SSHIFTS = (rt_ops[9] > -1)?rt_ops[9]:DFSHIFTS;
       if (sim_op == -1)
         sim_op = 1;
       else  if (ser_pats  < last_pat + 1)
         sim_op = 0;
       else 
         sim_op = 2;
     end 
     if (p_mode || (csim_op==1 || csim_op==2)) display_ops (p_mode, SSHIFTS, RT_OPS[9]);
     if (sim_op > -1)
       set_sim_ops (sim_op);
     else if (csim_op > -1)
       set_sim_ops (csim_op);
     if (rt_ops[0] > -1) begin
       verbose = rt_ops[0];
     end
     if (verbose != 0) 
       display_ops ((rt_ops[0]>-1), verbose, RT_OPS[0]);
     if (rt_ops[1] > -1) begin
       rep_pat =  rt_ops[1];
     end
     if (rep_pat != 5) 
       display_ops ((rt_ops[1]>-1), rep_pat, RT_OPS[1]);
     if (rt_ops[10] != 0 && ($test$plusargs ("tmax_test_setup_only_once"))) begin
       test_setup_only_once = 1;
       rt_ops[10] = 1;
     end
     if (test_setup_only_once > 0) begin
       display_ops ((rt_ops[10]>-1), test_setup_only_once, RT_OPS[10]);
     end
     if ((rt_ops[7] > -1)) begin
       first_pat =  rt_ops[7];
         display_ops ((rt_ops[7] > 0), first_pat, RT_OPS[7]);
         $display("XTB: User requesting starting simulation from pattern %0d.", first_pat);  
        
     end 
     if ($test$plusargs ("tmax_test_setup_mode")) begin
       test_setup_mode = rt_ops[6];
       if (test_setup_mode > 3 || test_setup_mode  < 0 ) begin
         $display("XTB Error: test_setup_mode set to wrong value (%0d), valid range is [0..3]. Exiting...",  test_setup_mode);
         $finish;
       end
       display_ops ((rt_ops[6] >= 0), test_setup_mode, RT_OPS[6]);
       if (test_setup_mode == 1)
         $display("XTB: User requesting saving and stopping simulation after test_setup");
       else if (test_setup_mode == 2)
         $display("XTB: User requesting skipping test_setup simulation ");
       else if (test_setup_mode == 3)
         $display("XTB: User requesting saving simulation after test_setup and continuing");
     end
   end 
   endtask

   task display_ops;
     input reg rt;
     input integer val;
     input reg [32*8:1] opname;
   begin
     $display("XTB: Setting %0s option \"%0s\" to %0d.", (rt==1)?"runtime":"compile-time",  opname, val);
   end 
   endtask

   task display_help;
   integer op;
   begin
     init_rtops;
     $display("\n\n\t\t----------------------- Runtime Help ------------------------------\n");
     $display("XTB: Usage is: <sim_exec> +opt1=val1 +opt2=val2...");
     $display("     where  <sim_exec> is the simulation exec name, and opt1 opt2 are available options and val1, val2 their corresponding values.");
     $display("     Available runtime options are:");
     op = 0;
     while (op < `NBRTOPS) begin
       $display("        +%0s", RT_OPS[op]);
       op = op + 1;
     end
       $display("        +tmax_test_data_file");
     $display("\n      E.g.: simv +tmax_serial=2 +tmax_msg=2, runs first 2 patterns in serial and remaining in parallel, and set the verbose msg level to 2.");
     $display("\n      E.g.: simv +tmax_test_data_file=\"myfile.dat\" , where myfile.dat is the new .dat file");
     $display("\n Note: Runtime options override corresponding compile-time options.");
     $display("\n       Please refer to the User's Guide for details regarding each option.");
     $display("\n\t\t-------------------------------------------------------------------\n");
   end 
   endtask

   task set_sim_ops;
     input integer smode;
   begin
     if (smode==0) begin 
       xtb_sim_mode = 0;
       $write("XTB: Enabling serial simulation for");
       if (ser_pats < last_pat + 1) begin
         if (ser_pats==1) $write(" the first pattern.\n");
         else $write(" first %0d patterns.\n", ser_pats);
       end else 
         $write(" all patterns.\n");
     end
     else if (smode==1) begin 
       $write("XTB: Enabling parallel simulation with %0d serial shift(s).\n", SSHIFTS);
       xtb_sim_mode = 1;
     end 
     else  if (smode==2) begin
       $display("XTB Warning: requesting full serial simulation and full parallel simulation in the same time. Performing default parallel simulation mode...");
       xtb_sim_mode = 1;
     end 
   end 
   endtask

   task check_max_error_limit;
     begin
     if( rt_ops[3] > -1 && nbfails == rt_ops[3])    finish_at_max_error;
   end
     endtask

   task finish_at_max_error;
     begin
     $display("XTB: Simulation of %0d pattern%s completed with %0d mismatch%s (time: %0t, cycles: %0d)\n", cur_pat-first_pat+1, (cur_pat-first_pat+1==1)?"":"s", nbfails, (nbfails==1)?"":"es", $time, v_count); 
     $finish(0);
     end
     endtask


   initial begin: Internal_scan_occ_bypass_pattern__init_unit

     `ifdef tmax_fsdb
       $fsdbDumpvars;
     `endif


     for (n=0; n<SIG_IDS; n=n+1) SignalIDWidth[n] = 0;
     SignalIDName[0] = "clk";
     SignalIDType[0] = 0; //clk
     SignalIDWidth[0] = 1; //clk
     SignalIDName[1] = "TEST_SI1";
     SignalIDType[1] = 0; //TEST_SI1
     SignalIDWidth[1] = 1; //TEST_SI1
     SignalIDName[2] = "TEST_SI2";
     SignalIDType[2] = 0; //TEST_SI2
     SignalIDWidth[2] = 1; //TEST_SI2
     SignalIDName[3] = "TEST_SI3";
     SignalIDType[3] = 0; //TEST_SI3
     SignalIDWidth[3] = 1; //TEST_SI3
     SignalIDName[4] = "TEST_SI4";
     SignalIDType[4] = 0; //TEST_SI4
     SignalIDWidth[4] = 1; //TEST_SI4
     SignalIDName[5] = "TEST_SE";
     SignalIDType[5] = 0; //TEST_SE
     SignalIDWidth[5] = 1; //TEST_SE
     SignalIDName[6] = "scan_clk";
     SignalIDType[6] = 0; //scan_clk
     SignalIDWidth[6] = 1; //scan_clk
     SignalIDName[7] = "SCAN_MODE";
     SignalIDType[7] = 0; //SCAN_MODE
     SignalIDWidth[7] = 1; //SCAN_MODE
     SignalIDName[8] = "pll_bypass_2";
     SignalIDType[8] = 0; //pll_bypass_2
     SignalIDWidth[8] = 1; //pll_bypass_2
     SignalIDName[9] = "pll_bypass";
     SignalIDType[9] = 0; //pll_bypass
     SignalIDWidth[9] = 1; //pll_bypass
     SignalIDName[10] = "pll_reset";
     SignalIDType[10] = 0; //pll_reset
     SignalIDWidth[10] = 1; //pll_reset
     SignalIDName[11] = "TEST_SO1";
     SignalIDType[11] = 1; //TEST_SO1
     SignalIDWidth[11] = 1; //TEST_SO1
     SignalIDName[12] = "TEST_SO2";
     SignalIDType[12] = 1; //TEST_SO2
     SignalIDWidth[12] = 1; //TEST_SO2
     SignalIDName[13] = "TEST_SO3";
     SignalIDType[13] = 1; //TEST_SO3
     SignalIDWidth[13] = 1; //TEST_SO3
     SignalIDName[14] = "TEST_SO4";
     SignalIDType[14] = 1; //TEST_SO4
     SignalIDWidth[14] = 1; //TEST_SO4
     SignalIDName[15] = "_pi";
     SignalIDType[15] = 3; //_pi
     SignalIDWidth[15] = 11; //_pi
     SignalIDName[16] = "all_inputs";
     SignalIDType[16] = 3; //all_inputs
     SignalIDWidth[16] = 11; //all_inputs
     SignalIDName[17] = "_po";
     SignalIDType[17] = 3; //_po
     SignalIDWidth[17] = 4; //_po
     SignalIDName[18] = "_si";
     SignalIDType[18] = 3; //_si
     SignalIDWidth[18] = 4; //_si
     SignalIDName[19] = "all_outputs";
     SignalIDType[19] = 3; //all_outputs
     SignalIDWidth[19] = 4; //all_outputs
     SignalIDName[20] = "_clk";
     SignalIDType[20] = 3; //_clk
     SignalIDWidth[20] = 2; //_clk
     SignalIDName[21] = "_so";
     SignalIDType[21] = 3; //_so
     SignalIDWidth[21] = 4; //_so
     WFTIDName[0] = "_multiclock_capture_WFT_";
     WFTIDName[1] = "_allclock_capture_WFT_";
     WFTIDName[2] = "_allclock_launch_WFT_";
     WFTIDName[3] = "_allclock_launch_capture_WFT_";
     WFTIDName[4] = "_default_WFT_";
     StmtNames[0] = "SetLastReseed";
     StmtNames[1] = "EndPat";
     StmtNames[2] = "IncPat";
     StmtNames[3] = "SetPat";
     StmtNames[4] = "WFTStmt";
     StmtNames[5] = "ConditionStmt";
     StmtNames[6] = "VectorStmt";
     StmtNames[7] = "FixedStmt";
     StmtNames[8] = "GenLoopStmt";
     StmtNames[9] = "EndGenLoopStmt";
     StmtNames[10] = "GenTestSetupStmt";
     StmtNames[11] = "EndGenTestSetupStmt";
     StmtNames[12] = "SetForceSI";
     StmtNames[13] = "SetValidStrobe";
     StmtNames[14] = "AnnotationStmt";
     StmtNames[15] = "SetWPack";
     StmtNames[16] = "SetRPack";
     StmtNames[17] = "multiclock_captureStmt";
     StmtNames[18] = "allclock_captureStmt";
     StmtNames[19] = "allclock_launchStmt";
     StmtNames[20] = "allclock_launch_captureStmt";
     StmtNames[21] = "load_unloadStmt";
     StmtNames[22] = "test_setupStmt";

     $display("%s",`MAXTB_H_S);
     $display("%s",`MAXTB_HEADER);
     $display("%s\n",`MAXTB_H_S);

     if ( $test$plusargs ("tmax_help") ) begin
       display_help;
       $finish(0);
     end

     $timeformat(-9,2," ns",19);

     `ifdef tmax_test_data_file 
       tdfm = 1;
       TDATA_FILE = `tmax_test_data_file ;
     `else
       tdfm = 0;
       TDATA_FILE = `TDATA_FILE ;
     `endif


     `ifdef tmax_diag_file 
       diagm = 1;
       diag_file = `tmax_diag_file ;
     `else
       tdfm = 0;
       diag_file = "" ;
     `endif

     `ifdef tmax_vcde
       $display("XTB: Dumping Extended VCD information in file \"PATTERNS/MAXTB/Risc_16_bit_TF_Internal_scan_parallel_max_tb.vcd\"");
       $dumpports(`XTB_DUT_HIER, "PATTERNS/MAXTB/Risc_16_bit_TF_Internal_scan_parallel_max_tb.vcd");
     `endif

     `ifdef tmax_msg
       verbose = `tmax_msg ;
     `else
       verbose = 0 ;
     `endif

     `ifdef tmax_debug
     if (~(`tmax_debug & 1'b1) == 1'b0)
       debug = 1;
     else
       debug = `tmax_debug + 0 ;
     `else
     debug = 0 ;
     `endif

     `ifdef tmax_rpt
     rep_pat = `tmax_rpt ;
     `else
     rep_pat = 5 ;
     `endif

     test_setup_runs = 0;

     set_last_reseed = 1;

     test_setup_mode = 0;


     test_setup_done = 0;

     CH_NAMES[0] = "1";
     CH_PINS[0] = "TEST_SO1";
     CH_NAMES[1] = "2";
     CH_PINS[1] = "TEST_SO2";
     CH_NAMES[2] = "3";
     CH_PINS[2] = "TEST_SO3";
     CH_NAMES[3] = "4";
     CH_PINS[3] = "TEST_SO4";
     SC_NAMES[0] = "DU.dm.\memory_reg[5][10] ";     SC_NAMES[1] = "DU.dm.\memory_reg[5][9] "; SC_NAMES[2] = "DU.dm.\memory_reg[5][8] "; SC_NAMES[3] = "DU.dm.\memory_reg[5][7] "; SC_NAMES[4] = "DU.dm.\memory_reg[5][6] "; SC_NAMES[5] = "DU.dm.\memory_reg[5][5] "; SC_NAMES[6] = "DU.dm.\memory_reg[5][4] "; SC_NAMES[7] = "DU.dm.\memory_reg[5][3] "; SC_NAMES[8] = "DU.dm.\memory_reg[5][2] "; SC_NAMES[9] = "DU.dm.\memory_reg[5][1] "; SC_NAMES[10] = "DU.dm.\memory_reg[5][0] "; SC_NAMES[11] = "DU.dm.\memory_reg[4][15] "; SC_NAMES[12] = "DU.dm.\memory_reg[4][14] "; SC_NAMES[13] = "DU.dm.\memory_reg[4][13] "; SC_NAMES[14] = "DU.dm.\memory_reg[4][12] "; SC_NAMES[15] = "DU.dm.\memory_reg[4][11] "; SC_NAMES[16] = "DU.dm.\memory_reg[4][10] "; SC_NAMES[17] = "DU.dm.\memory_reg[4][9] "; SC_NAMES[18] = "DU.dm.\memory_reg[4][8] "; SC_NAMES[19] = "DU.dm.\memory_reg[4][7] "; SC_NAMES[20] = "DU.dm.\memory_reg[4][6] "; SC_NAMES[21] = "DU.dm.\memory_reg[4][5] "; SC_NAMES[22] = "DU.dm.\memory_reg[4][4] "; SC_NAMES[23] = "DU.dm.\memory_reg[4][3] "; SC_NAMES[24] = "DU.dm.\memory_reg[4][2] "; SC_NAMES[25] = "DU.dm.\memory_reg[4][1] "; SC_NAMES[26] = "DU.dm.\memory_reg[4][0] "; SC_NAMES[27] = "DU.dm.\memory_reg[3][15] "; SC_NAMES[28] = "DU.dm.\memory_reg[3][14] "; SC_NAMES[29] = "DU.dm.\memory_reg[3][13] "; SC_NAMES[30] = "DU.dm.\memory_reg[3][12] "; SC_NAMES[31] = "DU.dm.\memory_reg[3][11] "; SC_NAMES[32] = "DU.dm.\memory_reg[3][10] "; SC_NAMES[33] = "DU.dm.\memory_reg[3][9] "; SC_NAMES[34] = "DU.dm.\memory_reg[3][8] "; SC_NAMES[35] = "DU.dm.\memory_reg[3][7] "; SC_NAMES[36] = "DU.dm.\memory_reg[3][6] "; SC_NAMES[37] = "DU.dm.\memory_reg[3][5] "; SC_NAMES[38] = "DU.dm.\memory_reg[3][4] "; SC_NAMES[39] = "DU.dm.\memory_reg[3][3] "; SC_NAMES[40] = "DU.dm.\memory_reg[3][2] "; SC_NAMES[41] = "DU.dm.\memory_reg[3][1] "; SC_NAMES[42] = "DU.dm.\memory_reg[3][0] "; SC_NAMES[43] = "DU.dm.\memory_reg[2][15] "; SC_NAMES[44] = "DU.dm.\memory_reg[2][14] "; SC_NAMES[45] = "DU.dm.\memory_reg[2][13] "; SC_NAMES[46] = "DU.dm.\memory_reg[2][12] "; SC_NAMES[47] = "DU.dm.\memory_reg[2][11] ";
     SC_NAMES[48] = "DU.dm.\memory_reg[2][10] "; SC_NAMES[49] = "DU.dm.\memory_reg[2][9] "; SC_NAMES[50] = "DU.dm.\memory_reg[2][8] "; SC_NAMES[51] = "DU.dm.\memory_reg[2][7] "; SC_NAMES[52] = "DU.dm.\memory_reg[2][6] "; SC_NAMES[53] = "DU.dm.\memory_reg[2][5] "; SC_NAMES[54] = "DU.dm.\memory_reg[2][4] "; SC_NAMES[55] = "DU.dm.\memory_reg[2][3] "; SC_NAMES[56] = "DU.dm.\memory_reg[2][2] "; SC_NAMES[57] = "DU.dm.\memory_reg[2][1] "; SC_NAMES[58] = "DU.dm.\memory_reg[2][0] "; SC_NAMES[59] = "DU.dm.\memory_reg[1][15] "; SC_NAMES[60] = "DU.dm.\memory_reg[1][14] "; SC_NAMES[61] = "DU.dm.\memory_reg[1][13] "; SC_NAMES[62] = "DU.dm.\memory_reg[1][12] "; SC_NAMES[63] = "DU.dm.\memory_reg[1][11] "; SC_NAMES[64] = "DU.dm.\memory_reg[1][10] "; SC_NAMES[65] = "DU.dm.\memory_reg[1][9] "; SC_NAMES[66] = "DU.dm.\memory_reg[1][8] "; SC_NAMES[67] = "DU.dm.\memory_reg[1][7] "; SC_NAMES[68] = "DU.dm.\memory_reg[1][6] "; SC_NAMES[69] = "DU.dm.\memory_reg[1][5] "; SC_NAMES[70] = "DU.dm.\memory_reg[1][4] "; SC_NAMES[71] = "DU.dm.\memory_reg[1][3] "; SC_NAMES[72] = "DU.dm.\memory_reg[1][2] "; SC_NAMES[73] = "DU.dm.\memory_reg[1][1] "; SC_NAMES[74] = "DU.dm.\memory_reg[1][0] "; SC_NAMES[75] = "DU.dm.\memory_reg[0][15] "; SC_NAMES[76] = "DU.dm.\memory_reg[0][14] "; SC_NAMES[77] = "DU.dm.\memory_reg[0][13] "; SC_NAMES[78] = "DU.dm.\memory_reg[0][12] "; SC_NAMES[79] = "DU.dm.\memory_reg[0][11] "; SC_NAMES[80] = "DU.dm.\memory_reg[0][10] "; SC_NAMES[81] = "DU.dm.\memory_reg[0][9] "; SC_NAMES[82] = "DU.dm.\memory_reg[0][8] "; SC_NAMES[83] = "DU.dm.\memory_reg[0][7] "; SC_NAMES[84] = "DU.dm.\memory_reg[0][6] "; SC_NAMES[85] = "DU.dm.\memory_reg[0][5] "; SC_NAMES[86] = "DU.dm.\memory_reg[0][4] "; SC_NAMES[87] = "DU.dm.\memory_reg[0][3] "; SC_NAMES[88] = "DU.dm.\memory_reg[0][2] "; SC_NAMES[89] = "DU.dm.\memory_reg[0][1] "; SC_NAMES[90] = "DU.dm.\memory_reg[0][0] "; SC_NAMES[91] = "snps_clk_chain_0.\U_shftreg_0/ff_0/q_reg "; SC_NAMES[92] = "snps_clk_chain_0.\U_shftreg_0/ff_1/q_reg "; SC_NAMES[93] = "snps_clk_chain_0.\U_shftreg_0/ff_2/q_reg "; SC_NAMES[94] = "snps_clk_chain_0.\U_shftreg_0/ff_3/q_reg ";
     SC_NAMES[95] = "-"; SC_NAMES[96] = "-"; SC_NAMES[97] = "-"; SC_NAMES[98] = "-"; SC_NAMES[99] = "-"; SC_NAMES[100] = "-"; SC_NAMES[101] = "-"; SC_NAMES[102] = "-"; SC_NAMES[103] = "-"; SC_NAMES[104] = "-"; SC_NAMES[105] = "-"; SC_NAMES[106] = "-"; SC_NAMES[107] = "-"; SC_NAMES[108] = "-"; SC_NAMES[109] = "-"; SC_NAMES[110] = "-"; SC_NAMES[111] = "-"; SC_NAMES[112] = "-"; SC_NAMES[113] = "-"; SC_NAMES[114] = "-"; SC_NAMES[115] = "-"; SC_NAMES[116] = "-"; SC_NAMES[117] = "-"; SC_NAMES[118] = "-"; SC_NAMES[119] = "-"; SC_NAMES[120] = "-"; SC_NAMES[121] = "-"; SC_NAMES[122] = "-"; SC_NAMES[123] = "-"; SC_NAMES[124] = "-"; SC_NAMES[125] = "-"; SC_NAMES[126] = "-"; SC_NAMES[127] = "-"; SC_NAMES[128] = "-"; SC_NAMES[129] = "-"; SC_NAMES[130] = "-"; SC_NAMES[131] = "-"; SC_NAMES[132] = "-"; SC_NAMES[133] = "-"; SC_NAMES[134] = "-"; SC_NAMES[135] = "-"; SC_NAMES[136] = "-"; SC_NAMES[137] = "-"; SC_NAMES[138] = "-"; SC_NAMES[139] = "-"; SC_NAMES[140] = "-"; SC_NAMES[141] = "-";
     SC_NAMES[142] = "-"; SC_NAMES[143] = "-"; SC_NAMES[144] = "-"; SC_NAMES[145] = "-"; SC_NAMES[146] = "-"; SC_NAMES[147] = "-"; SC_NAMES[148] = "-"; SC_NAMES[149] = "-"; SC_NAMES[150] = "-"; SC_NAMES[151] = "-"; SC_NAMES[152] = "-"; SC_NAMES[153] = "-"; SC_NAMES[154] = "-"; SC_NAMES[155] = "-"; SC_NAMES[156] = "-"; SC_NAMES[157] = "-"; SC_NAMES[158] = "-"; SC_NAMES[159] = "-"; SC_NAMES[160] = "-"; SC_NAMES[161] = "-"; SC_NAMES[162] = "-"; SC_NAMES[163] = "-"; SC_NAMES[164] = "-"; SC_NAMES[165] = "-"; SC_NAMES[166] = "-"; SC_NAMES[167] = "-"; SC_NAMES[168] = "-"; SC_NAMES[169] = "-"; SC_NAMES[170] = "-"; SC_NAMES[171] = "-"; SC_NAMES[172] = "-"; SC_NAMES[173] = "-"; SC_NAMES[174] = "-"; SC_NAMES[175] = "-"; SC_NAMES[176] = "-"; SC_NAMES[177] = "-"; SC_NAMES[178] = "-"; SC_NAMES[179] = "-"; SC_NAMES[180] = "-"; SC_NAMES[181] = "-"; SC_NAMES[182] = "DU.reg_file.\reg_array_reg[2][5] "; SC_NAMES[183] = "DU.reg_file.\reg_array_reg[2][4] "; SC_NAMES[184] = "DU.reg_file.\reg_array_reg[2][3] "; SC_NAMES[185] = "DU.reg_file.\reg_array_reg[2][2] "; SC_NAMES[186] = "DU.reg_file.\reg_array_reg[2][1] "; SC_NAMES[187] = "DU.reg_file.\reg_array_reg[2][0] "; SC_NAMES[188] = "DU.reg_file.\reg_array_reg[1][15] ";
     SC_NAMES[189] = "DU.reg_file.\reg_array_reg[1][14] "; SC_NAMES[190] = "DU.reg_file.\reg_array_reg[1][13] "; SC_NAMES[191] = "DU.reg_file.\reg_array_reg[1][12] "; SC_NAMES[192] = "DU.reg_file.\reg_array_reg[1][11] "; SC_NAMES[193] = "DU.reg_file.\reg_array_reg[1][10] "; SC_NAMES[194] = "DU.reg_file.\reg_array_reg[1][9] "; SC_NAMES[195] = "DU.reg_file.\reg_array_reg[1][8] "; SC_NAMES[196] = "DU.reg_file.\reg_array_reg[1][7] "; SC_NAMES[197] = "DU.reg_file.\reg_array_reg[1][6] "; SC_NAMES[198] = "DU.reg_file.\reg_array_reg[1][5] "; SC_NAMES[199] = "DU.reg_file.\reg_array_reg[1][4] "; SC_NAMES[200] = "DU.reg_file.\reg_array_reg[1][3] "; SC_NAMES[201] = "DU.reg_file.\reg_array_reg[1][2] "; SC_NAMES[202] = "DU.reg_file.\reg_array_reg[1][1] "; SC_NAMES[203] = "DU.reg_file.\reg_array_reg[1][0] "; SC_NAMES[204] = "DU.reg_file.\reg_array_reg[0][15] "; SC_NAMES[205] = "DU.reg_file.\reg_array_reg[0][14] "; SC_NAMES[206] = "DU.reg_file.\reg_array_reg[0][13] "; SC_NAMES[207] = "DU.reg_file.\reg_array_reg[0][12] "; SC_NAMES[208] = "DU.reg_file.\reg_array_reg[0][11] "; SC_NAMES[209] = "DU.reg_file.\reg_array_reg[0][10] "; SC_NAMES[210] = "DU.reg_file.\reg_array_reg[0][9] "; SC_NAMES[211] = "DU.reg_file.\reg_array_reg[0][8] "; SC_NAMES[212] = "DU.reg_file.\reg_array_reg[0][7] "; SC_NAMES[213] = "DU.reg_file.\reg_array_reg[0][6] "; SC_NAMES[214] = "DU.reg_file.\reg_array_reg[0][5] "; SC_NAMES[215] = "DU.reg_file.\reg_array_reg[0][4] "; SC_NAMES[216] = "DU.reg_file.\reg_array_reg[0][3] "; SC_NAMES[217] = "DU.reg_file.\reg_array_reg[0][2] "; SC_NAMES[218] = "DU.reg_file.\reg_array_reg[0][1] "; SC_NAMES[219] = "DU.reg_file.\reg_array_reg[0][0] "; SC_NAMES[220] = "DU.\pc_current_reg[15] "; SC_NAMES[221] = "DU.\pc_current_reg[14] "; SC_NAMES[222] = "DU.\pc_current_reg[13] "; SC_NAMES[223] = "DU.\pc_current_reg[12] "; SC_NAMES[224] = "DU.\pc_current_reg[11] "; SC_NAMES[225] = "DU.\pc_current_reg[10] "; SC_NAMES[226] = "DU.\pc_current_reg[9] "; SC_NAMES[227] = "DU.\pc_current_reg[8] "; SC_NAMES[228] = "DU.\pc_current_reg[7] "; SC_NAMES[229] = "DU.\pc_current_reg[6] "; SC_NAMES[230] = "DU.\pc_current_reg[5] "; SC_NAMES[231] = "DU.\pc_current_reg[4] "; SC_NAMES[232] = "DU.\pc_current_reg[3] "; SC_NAMES[233] = "DU.\pc_current_reg[2] "; SC_NAMES[234] = "DU.\pc_current_reg[1] "; SC_NAMES[235] = "DU.\pc_current_reg[0] ";
     SC_NAMES[236] = "DU.dm.\memory_reg[7][15] "; SC_NAMES[237] = "DU.dm.\memory_reg[7][14] "; SC_NAMES[238] = "DU.dm.\memory_reg[7][13] "; SC_NAMES[239] = "DU.dm.\memory_reg[7][12] "; SC_NAMES[240] = "DU.dm.\memory_reg[7][11] "; SC_NAMES[241] = "DU.dm.\memory_reg[7][10] "; SC_NAMES[242] = "DU.dm.\memory_reg[7][9] "; SC_NAMES[243] = "DU.dm.\memory_reg[7][8] "; SC_NAMES[244] = "DU.dm.\memory_reg[7][7] "; SC_NAMES[245] = "DU.dm.\memory_reg[7][6] "; SC_NAMES[246] = "DU.dm.\memory_reg[7][5] "; SC_NAMES[247] = "DU.dm.\memory_reg[7][4] "; SC_NAMES[248] = "DU.dm.\memory_reg[7][3] "; SC_NAMES[249] = "DU.dm.\memory_reg[7][2] "; SC_NAMES[250] = "DU.dm.\memory_reg[7][1] "; SC_NAMES[251] = "DU.dm.\memory_reg[7][0] "; SC_NAMES[252] = "DU.dm.\memory_reg[6][15] "; SC_NAMES[253] = "DU.dm.\memory_reg[6][14] "; SC_NAMES[254] = "DU.dm.\memory_reg[6][13] "; SC_NAMES[255] = "DU.dm.\memory_reg[6][12] "; SC_NAMES[256] = "DU.dm.\memory_reg[6][11] "; SC_NAMES[257] = "DU.dm.\memory_reg[6][10] "; SC_NAMES[258] = "DU.dm.\memory_reg[6][9] "; SC_NAMES[259] = "DU.dm.\memory_reg[6][8] "; SC_NAMES[260] = "DU.dm.\memory_reg[6][7] "; SC_NAMES[261] = "DU.dm.\memory_reg[6][6] "; SC_NAMES[262] = "DU.dm.\memory_reg[6][5] "; SC_NAMES[263] = "DU.dm.\memory_reg[6][4] "; SC_NAMES[264] = "DU.dm.\memory_reg[6][3] "; SC_NAMES[265] = "DU.dm.\memory_reg[6][2] "; SC_NAMES[266] = "DU.dm.\memory_reg[6][1] "; SC_NAMES[267] = "DU.dm.\memory_reg[6][0] "; SC_NAMES[268] = "DU.dm.\memory_reg[5][15] "; SC_NAMES[269] = "DU.dm.\memory_reg[5][14] "; SC_NAMES[270] = "DU.dm.\memory_reg[5][13] "; SC_NAMES[271] = "DU.dm.\memory_reg[5][12] "; SC_NAMES[272] = "DU.dm.\memory_reg[5][11] "; SC_NAMES[273] = "DU.reg_file.\reg_array_reg[7][15] "; SC_NAMES[274] = "DU.reg_file.\reg_array_reg[7][14] "; SC_NAMES[275] = "DU.reg_file.\reg_array_reg[7][13] "; SC_NAMES[276] = "DU.reg_file.\reg_array_reg[7][12] "; SC_NAMES[277] = "DU.reg_file.\reg_array_reg[7][11] "; SC_NAMES[278] = "DU.reg_file.\reg_array_reg[7][10] "; SC_NAMES[279] = "DU.reg_file.\reg_array_reg[7][9] "; SC_NAMES[280] = "DU.reg_file.\reg_array_reg[7][8] "; SC_NAMES[281] = "DU.reg_file.\reg_array_reg[7][7] "; SC_NAMES[282] = "DU.reg_file.\reg_array_reg[7][6] ";
     SC_NAMES[283] = "DU.reg_file.\reg_array_reg[7][5] "; SC_NAMES[284] = "DU.reg_file.\reg_array_reg[7][4] "; SC_NAMES[285] = "DU.reg_file.\reg_array_reg[7][3] "; SC_NAMES[286] = "DU.reg_file.\reg_array_reg[7][2] "; SC_NAMES[287] = "DU.reg_file.\reg_array_reg[7][1] "; SC_NAMES[288] = "DU.reg_file.\reg_array_reg[7][0] "; SC_NAMES[289] = "DU.reg_file.\reg_array_reg[6][15] "; SC_NAMES[290] = "DU.reg_file.\reg_array_reg[6][14] "; SC_NAMES[291] = "DU.reg_file.\reg_array_reg[6][13] "; SC_NAMES[292] = "DU.reg_file.\reg_array_reg[6][12] "; SC_NAMES[293] = "DU.reg_file.\reg_array_reg[6][11] "; SC_NAMES[294] = "DU.reg_file.\reg_array_reg[6][10] "; SC_NAMES[295] = "DU.reg_file.\reg_array_reg[6][9] "; SC_NAMES[296] = "DU.reg_file.\reg_array_reg[6][8] "; SC_NAMES[297] = "DU.reg_file.\reg_array_reg[6][7] "; SC_NAMES[298] = "DU.reg_file.\reg_array_reg[6][6] "; SC_NAMES[299] = "DU.reg_file.\reg_array_reg[6][5] "; SC_NAMES[300] = "DU.reg_file.\reg_array_reg[6][4] "; SC_NAMES[301] = "DU.reg_file.\reg_array_reg[6][3] "; SC_NAMES[302] = "DU.reg_file.\reg_array_reg[6][2] "; SC_NAMES[303] = "DU.reg_file.\reg_array_reg[6][1] "; SC_NAMES[304] = "DU.reg_file.\reg_array_reg[6][0] "; SC_NAMES[305] = "DU.reg_file.\reg_array_reg[5][15] "; SC_NAMES[306] = "DU.reg_file.\reg_array_reg[5][14] "; SC_NAMES[307] = "DU.reg_file.\reg_array_reg[5][13] "; SC_NAMES[308] = "DU.reg_file.\reg_array_reg[5][12] "; SC_NAMES[309] = "DU.reg_file.\reg_array_reg[5][11] "; SC_NAMES[310] = "DU.reg_file.\reg_array_reg[5][10] "; SC_NAMES[311] = "DU.reg_file.\reg_array_reg[5][9] "; SC_NAMES[312] = "DU.reg_file.\reg_array_reg[5][8] "; SC_NAMES[313] = "DU.reg_file.\reg_array_reg[5][7] "; SC_NAMES[314] = "DU.reg_file.\reg_array_reg[5][6] "; SC_NAMES[315] = "DU.reg_file.\reg_array_reg[5][5] "; SC_NAMES[316] = "DU.reg_file.\reg_array_reg[5][4] "; SC_NAMES[317] = "DU.reg_file.\reg_array_reg[5][3] "; SC_NAMES[318] = "DU.reg_file.\reg_array_reg[5][2] "; SC_NAMES[319] = "DU.reg_file.\reg_array_reg[5][1] "; SC_NAMES[320] = "DU.reg_file.\reg_array_reg[5][0] "; SC_NAMES[321] = "DU.reg_file.\reg_array_reg[4][15] "; SC_NAMES[322] = "DU.reg_file.\reg_array_reg[4][14] "; SC_NAMES[323] = "DU.reg_file.\reg_array_reg[4][13] "; SC_NAMES[324] = "DU.reg_file.\reg_array_reg[4][12] "; SC_NAMES[325] = "DU.reg_file.\reg_array_reg[4][11] "; SC_NAMES[326] = "DU.reg_file.\reg_array_reg[4][10] "; SC_NAMES[327] = "DU.reg_file.\reg_array_reg[4][9] "; SC_NAMES[328] = "DU.reg_file.\reg_array_reg[4][8] "; SC_NAMES[329] = "DU.reg_file.\reg_array_reg[4][7] ";
     SC_NAMES[330] = "DU.reg_file.\reg_array_reg[4][6] "; SC_NAMES[331] = "DU.reg_file.\reg_array_reg[4][5] "; SC_NAMES[332] = "DU.reg_file.\reg_array_reg[4][4] "; SC_NAMES[333] = "DU.reg_file.\reg_array_reg[4][3] "; SC_NAMES[334] = "DU.reg_file.\reg_array_reg[4][2] "; SC_NAMES[335] = "DU.reg_file.\reg_array_reg[4][1] "; SC_NAMES[336] = "DU.reg_file.\reg_array_reg[4][0] "; SC_NAMES[337] = "DU.reg_file.\reg_array_reg[3][15] "; SC_NAMES[338] = "DU.reg_file.\reg_array_reg[3][14] "; SC_NAMES[339] = "DU.reg_file.\reg_array_reg[3][13] "; SC_NAMES[340] = "DU.reg_file.\reg_array_reg[3][12] "; SC_NAMES[341] = "DU.reg_file.\reg_array_reg[3][11] "; SC_NAMES[342] = "DU.reg_file.\reg_array_reg[3][10] "; SC_NAMES[343] = "DU.reg_file.\reg_array_reg[3][9] "; SC_NAMES[344] = "DU.reg_file.\reg_array_reg[3][8] "; SC_NAMES[345] = "DU.reg_file.\reg_array_reg[3][7] "; SC_NAMES[346] = "DU.reg_file.\reg_array_reg[3][6] "; SC_NAMES[347] = "DU.reg_file.\reg_array_reg[3][5] "; SC_NAMES[348] = "DU.reg_file.\reg_array_reg[3][4] "; SC_NAMES[349] = "DU.reg_file.\reg_array_reg[3][3] "; SC_NAMES[350] = "DU.reg_file.\reg_array_reg[3][2] "; SC_NAMES[351] = "DU.reg_file.\reg_array_reg[3][1] "; SC_NAMES[352] = "DU.reg_file.\reg_array_reg[3][0] "; SC_NAMES[353] = "DU.reg_file.\reg_array_reg[2][15] "; SC_NAMES[354] = "DU.reg_file.\reg_array_reg[2][14] "; SC_NAMES[355] = "DU.reg_file.\reg_array_reg[2][13] "; SC_NAMES[356] = "DU.reg_file.\reg_array_reg[2][12] "; SC_NAMES[357] = "DU.reg_file.\reg_array_reg[2][11] "; SC_NAMES[358] = "DU.reg_file.\reg_array_reg[2][10] "; SC_NAMES[359] = "DU.reg_file.\reg_array_reg[2][9] "; SC_NAMES[360] = "DU.reg_file.\reg_array_reg[2][8] "; SC_NAMES[361] = "DU.reg_file.\reg_array_reg[2][7] "; SC_NAMES[362] = "DU.reg_file.\reg_array_reg[2][6] "; SC_NAMES[363] = "-";     CH_OUTINV[0] = 91'b0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010;
     CH_INPINV[0] = 91'b0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010;
     CT_OUTINV[0] = 91'b0111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111;
     CH_OUTINV[1] = 91'b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
     CH_INPINV[1] = 91'b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
     CT_OUTINV[1] = 91'b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
     CH_OUTINV[2] = 91'b0101010101010101010101111111111111101010101010101010101010101010101010101010101010101010101;
     CH_INPINV[2] = 91'b1010101010101010101010000000000000010101010101010101010101010101010101010101010101010101010;
     CT_OUTINV[2] = 91'b0111111111111111111111000000000000011111111111111111111111111111111111111111111111111111111;
     CH_OUTINV[3] = 91'b0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010;
     CH_INPINV[3] = 91'b1101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010;
     CT_OUTINV[3] = 91'b0111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110;

     diagm = 0;
     diag_file = "";

     `ifdef tmax_diag 
       diagm = `tmax_diag;
     `endif

     -> start_part;
     @(end_part) #0;
     $finish(0);

   end

 endmodule
